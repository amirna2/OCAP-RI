// COPYRIGHT_BEGIN
//  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER
//  
//  Copyright (C) 2008-2013, Cable Television Laboratories, Inc. 
//  
//  This software is available under multiple licenses: 
//  
//  (1) BSD 2-clause 
//   Redistribution and use in source and binary forms, with or without modification, are
//   permitted provided that the following conditions are met:
//        ·Redistributions of source code must retain the above copyright notice, this list 
//             of conditions and the following disclaimer.
//        ·Redistributions in binary form must reproduce the above copyright notice, this list of conditions 
//             and the following disclaimer in the documentation and/or other materials provided with the 
//             distribution.
//   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
//   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED 
//   TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
//   PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
//   HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
//   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
//   LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, 
//   DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY 
//   THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
//   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF 
//   THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//  
//  (2) GPL Version 2
//   This program is free software; you can redistribute it and/or modify
//   it under the terms of the GNU General Public License as published by
//   the Free Software Foundation, version 2. This program is distributed
//   in the hope that it will be useful, but WITHOUT ANY WARRANTY; without
//   even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
//   PURPOSE. See the GNU General Public License for more details.
//  
//   You should have received a copy of the GNU General Public License along
//   with this program.If not, see<http:www.gnu.org/licenses/>.
//  
//  (3)CableLabs License
//   If you or the company you represent has a separate agreement with CableLabs
//   concerning the use of this code, your rights and obligations with respect
//   to this code shall be as set forth therein. No license is granted hereunder
//   for any other purpose.
//  
//   Please contact CableLabs if you need additional information or 
//   have any questions.
//  
//       CableLabs
//       858 Coal Creek Cir
//       Louisville, CO 80027-9750
//       303 661-9100
// COPYRIGHT_END

package org.cablelabs.impl.manager.system.html;

import java.awt.Color;
import java.lang.reflect.Method;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import java.util.Map;

/**
 * 
 * The Document class represents HTML documents as defined by the Baseline HTML
 * profile (CCIF2.0, Annex A). It mimics the behavior of modern browsers on the
 * set of supported tags. Documents objects are constructed from the stream of
 * tags generated by the Parser class.
 * 
 * There is no need to support JavaScript and the standard DOM, so many
 * simplifications to the document structure can be made as it is read that will
 * simplify layout and that would not be allowed with the standard DOM.
 * 
 * The only supported structural tags are P, CENTER, A, and BR. Images, tables,
 * lists, forms, etc., are not supported. This means that documents consist only
 * of paragraphs containing text, links, and line breaks.
 * 
 * Text outside of a P tag is wrapped with an implicit P tag. An opening P tag
 * closes the current paragraph, if any. A /P tag with no matching P is treated
 * like an empty paragraph.
 * 
 * There is no support for CSS. All styling is done using the style tags B, I,
 * U, and FONT. These tags are handled independently of the other tags. A
 * running "total" of the style tags is kept and is used to create an actual
 * style for text when needed.
 * 
 * Paragraphs can be enclosed in style tags, and the styles apply to the text
 * within the paragraphs. The one style that applies directly to paragraphs is
 * the font size, which controls the spacing above and below the paragraph.
 * 
 * BR tags insert line breaks. As text is added to paragraphs, all leading and
 * trailing whitespace is removed. All whitespace between two adjacent runs of
 * text is collapsed into a single space. A BR tag will then insert a newline;
 * therefore, the only surviving newlines in the paragraph text will be from BR
 * tags. These newlines will carry the current text style, which controls the
 * size of the empty lines that result from multiple consecutive BR tags.
 * 
 * An A tag begins a link. Any open link tags are closed. Links apply only to
 * text, not to paragraphs. This is slightly different from the behavior of
 * modern browsers, which treat the contained paragraphs themselves as a link.
 * The only noticeable effect of this behavior is that the space between such
 * paragraphs is clickable. This HTML implementation will not support pointing
 * devices, so this difference is irrelevant. If an A tag has no HREF attribute,
 * the tag is ignored.
 * 
 * A link can contain arbitrary formatted text. By default, link text is
 * underlined and displayed with the link color, but FONT tags can override the
 * color and can add bold and italic styles. The underline can't be removed.
 * 
 * @author Spencer Schumann
 * 
 */
public class Document
{
    private final List paragraphs;

    private final Color backgroundColor;

    private final Color textColor;

    private final Color linkColor;

    /**
     * Create a document builder object.
     */
    public static Builder builder()
    {
        return new Builder();
    }

    /**
     * Get the document's background color.
     * 
     * @return background color
     */
    public Color getBackgroundColor()
    {
        return backgroundColor;
    }

    /**
     * Get the document's text color.
     * 
     * @return text color
     */
    public Color getTextColor()
    {
        return textColor;
    }

    /**
     * Get the document's link color.
     * 
     * @return link color
     */
    public Color getLinkColor()
    {
        return linkColor;
    }

    /**
     * Gets an iterator for the paragraphs in this document. Each object
     * returned by the iterator is a Paragraph.
     * 
     * @return iterator
     */
    public Iterator iterator()
    {
        return paragraphs.iterator();
    }

    /**
     * Private constructor used by the Builder class to create a Document
     * instance.
     * 
     * @param paragraphs
     *            list of paragraphs in the document
     * @param backgroundColor
     *            document's background color
     * @param textColor
     *            document's text color
     * @param linkColor
     *            document's link color
     */
    private Document(List paragraphs, Color backgroundColor, Color textColor, Color linkColor)
    {
        this.paragraphs = paragraphs;
        this.backgroundColor = backgroundColor;
        this.textColor = textColor;
        this.linkColor = linkColor;
    }

    /**
     * Document builder that takes as input the tags produced by the Parser
     * class and creates an immutable Document object.
     */
    public static class Builder extends ReflectiveTagHandler
    {
        private final ArrayList paragraphs = new ArrayList();

        private final TextStyle style = new TextStyle();

        private Paragraph.Builder currentParagraph = null;

        private String hyperlink = null;

        private int centerCount = 0;

        private Color backgroundColor = new Color(0xc0c0c0);

        private Color textColor = Color.BLACK;

        private Color linkColor = Color.BLUE;

        private boolean backgroundColorSet = false;

        private boolean textColorSet = false;

        private boolean linkColorSet = false;

        private static final String ATTR_HREF = "href";

        private static final String ATTR_BGCOLOR = "bgcolor";

        private static final String ATTR_TEXT = "text";

        private static final String ATTR_LINK = "link";

        private static final String ATTR_ALIGN = "align";

        private static final String ATTR_SIZE = "size";

        private static final String ATTR_COLOR = "color";

        private static final Map startTagMethods = createMethodMap(Builder.class, "start_");

        private static final Map endTagMethods = createMethodMap(Builder.class, "end_");

        /*
         * (non-Javadoc)
         * 
         * @see org.cablelabs.impl.manager.system.html.ReflectiveTagHandler#
         * getStartTagMethod(java.lang.String)
         */
        public Method getStartTagMethod(String name)
        {
            return (Method) startTagMethods.get(name);
        }

        /*
         * (non-Javadoc)
         * 
         * @see org.cablelabs.impl.manager.system.html.ReflectiveTagHandler#
         * getEndTagMethod(java.lang.String)
         */
        public Method getEndTagMethod(String name)
        {
            return (Method) endTagMethods.get(name);
        }

        /**
         * Create a document based on the current state of this builder.
         * 
         * @return document
         */
        public Document build()
        {
            ArrayList finalParagraphs = new ArrayList(paragraphs.size());
            Iterator i = paragraphs.iterator();
            while (i.hasNext())
            {
                Paragraph.Builder p = (Paragraph.Builder) i.next();
                finalParagraphs.add(p.build(textColor));
            }

            return new Document(finalParagraphs, backgroundColor, textColor, linkColor);
        }

        /*
         * (non-Javadoc)
         * 
         * @see
         * org.cablelabs.impl.manager.system.html.TagHandler#text(java.lang.
         * String)
         */
        public void text(String text)
        {
            Map attributes = style.build();

            if (null != hyperlink)
            {
                attributes.put(TextStyle.HYPERLINK, hyperlink);
            }

            if (null == currentParagraph)
            {
                // Only create a paragraph here if text contains non-whitespace.
                for (int i = 0; i < text.length(); i++)
                {
                    if (!Parser.isWhitespace(text.charAt(i)))
                    {
                        currentParagraph = createParagraph();
                        break;
                    }
                }
            }

            if (null != currentParagraph)
            {
                currentParagraph.addText(text, attributes);
            }
        }

        /**
         * Add BODY tag attributes to the document. No actual BODY node needs to
         * be added (subsumed by the document), but the attributes need to be
         * saved. Nothing needs to be done for the /BODY tag.
         * 
         * @param attributes
         *            map of tag attributes
         */
        public void start_BODY(Map attributes)
        {
            if (!backgroundColorSet)
            {
                Color color = ColorTranslator.translate((String) attributes.get(ATTR_BGCOLOR));
                if (null != color)
                {
                    backgroundColor = color;
                    backgroundColorSet = true;
                }
            }

            if (!textColorSet)
            {
                Color color = ColorTranslator.translate((String) attributes.get(ATTR_TEXT));
                if (null != color)
                {
                    textColor = color;
                    textColorSet = true;
                }
            }

            if (!linkColorSet)
            {
                Color color = ColorTranslator.translate((String) attributes.get(ATTR_LINK));
                if (null != color)
                {
                    linkColor = color;
                    linkColorSet = true;
                }
            }
        }

        /**
         * Handle P tag - start a new paragraph.
         * 
         * @param attributes
         *            map of tag attributes
         */
        public void start_P(Map attributes)
        {
            currentParagraph = createParagraph();
            currentParagraph.setMargin(style.getFontSize());

            String align = (String) attributes.get(ATTR_ALIGN);
            if (null != align)
            {
                if (align.equalsIgnoreCase("right"))
                {
                    currentParagraph.setAlignment(Paragraph.RIGHT);
                }
                else if (align.equalsIgnoreCase("center"))
                {
                    currentParagraph.setAlignment(Paragraph.CENTER);
                }
                else if (align.equalsIgnoreCase("left"))
                {
                    currentParagraph.setAlignment(Paragraph.LEFT);
                }
            }
        }

        /**
         * Handle /P tag - end a paragraph.
         * 
         */
        public void end_P()
        {
            // TODO: </p> shouldn't close <center> tags
            if (null == currentParagraph)
            {
                // No matching <p> tag. Treat it like <p></p>.
                currentParagraph = createParagraph();
                currentParagraph.setMargin(style.getFontSize());
            }

            currentParagraph = null;
        }

        /**
         * Handle CENTER tag. Creates a new paragraph. All text is centered
         * until the /CENTER tag is encountered. This tag isn't required by the
         * Baseline HTML Profile, but some cards contain HTML that uses it.
         * 
         * @param attributes
         *            map of tag attributes
         */
        void start_CENTER(Map attributes)
        {
            centerCount++;
            currentParagraph = createParagraph();
            currentParagraph.setMargin(style.getFontSize());
        }

        /**
         * Handle /CENTER tag.
         * 
         */
        void end_CENTER()
        {
            // TODO: <center><p>...</p></center> is the same as <p
            // align=center>...</p> - in other words, it shouldn't create an
            // empty "centered" paragraph.
            if (centerCount > 0)
            {
                centerCount--;
                currentParagraph = null;
            }
        }

        /**
         * Handle BR tag, which inserts a line break. BR is an empty element, so
         * no end tag should be used.
         * 
         * @param attributes
         *            map of tag attributes
         */
        public void start_BR(Map attributes)
        {
            if (null == currentParagraph)
            {
                currentParagraph = createParagraph();
            }
            currentParagraph.addLineBreak(style.getFontSize());
        }

        /**
         * Handle A tag - create a hyperlink. The HREF attribute contains the
         * link target.
         * 
         * @param attributes
         *            map of tag attributes
         */
        public void start_A(Map attributes)
        {
            hyperlink = (String) attributes.get(ATTR_HREF);
            if (null != hyperlink)
            {
                style.setUnderlined();
                // Set the color to null so that the default link
                // color will be used
                style.setColor(null);
            }
        }

        /**
         * Handle /A tag.
         * 
         */
        public void end_A()
        {
            if (null != hyperlink)
            {
                style.clearUnderlined();
                style.clearColor();
                hyperlink = null;
            }
        }

        /**
         * Handle FONT tag. The SIZE attribute can be either an absolute
         * numerical size from 1 to 7, or a relative size such as "+1" or "-2"
         * meaning bigger or smaller than the default. The COLOR attribute sets
         * the text color.
         * 
         * @param attributes
         *            map of tag attributes
         */
        public void start_FONT(Map attributes)
        {
            String size = (String) attributes.get(ATTR_SIZE);
            String strColor = (String) attributes.get(ATTR_COLOR);
            style.setSize(size);

            Color color = ColorTranslator.translate(strColor);
            if (null == color)
            {
                color = style.getColor();
            }
            style.setColor(color);
        }

        /**
         * Handle /FONT tag.
         * 
         */
        public void end_FONT()
        {
            style.clearSize();
            style.clearColor();
        }

        /**
         * Handle B (bold) tag.
         * 
         * @param attributes
         *            map of tag attributes
         */
        public void start_B(Map attributes)
        {
            style.setBold();
        }

        /**
         * Handle /B tag.
         * 
         */
        public void end_B()
        {
            style.clearBold();
        }

        /**
         * Handle I (italic) tag.
         * 
         * @param attributes
         *            map of tag attributes
         */
        public void start_I(Map attributes)
        {
            style.setItalic();
        }

        /**
         * Handle /I tag.
         * 
         */
        public void end_I()
        {
            style.clearItalic();
        }

        /**
         * Handle U (underline) tag.
         * 
         * @param attributes
         *            map of tag attributes
         */
        public void start_U(Map attributes)
        {
            style.setUnderlined();
        }

        /**
         * Handle /U tag.
         */
        public void end_U()
        {
            style.clearUnderlined();
        }

        /**
         * Create a new paragraph and add it to the document under construction.
         * 
         * @return paragraph builder
         */
        private Paragraph.Builder createParagraph()
        {
            Paragraph.Builder p = Paragraph.builder();
            paragraphs.add(p);

            if (centerCount > 0)
            {
                p.setAlignment(Paragraph.CENTER);
            }

            return p;
        }

        /**
         * Private constructor to prevent direct instantiation and sub-classing.
         * 
         */
        private Builder()
        {
        }
    }
}
