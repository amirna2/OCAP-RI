// COPYRIGHT_BEGIN
//  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER
//  
//  Copyright (C) 2008-2013, Cable Television Laboratories, Inc. 
//  
//  This software is available under multiple licenses: 
//  
//  (1) BSD 2-clause 
//   Redistribution and use in source and binary forms, with or without modification, are
//   permitted provided that the following conditions are met:
//        ·Redistributions of source code must retain the above copyright notice, this list 
//             of conditions and the following disclaimer.
//        ·Redistributions in binary form must reproduce the above copyright notice, this list of conditions 
//             and the following disclaimer in the documentation and/or other materials provided with the 
//             distribution.
//   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
//   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED 
//   TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
//   PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
//   HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
//   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
//   LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, 
//   DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY 
//   THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
//   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF 
//   THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//  
//  (2) GPL Version 2
//   This program is free software; you can redistribute it and/or modify
//   it under the terms of the GNU General Public License as published by
//   the Free Software Foundation, version 2. This program is distributed
//   in the hope that it will be useful, but WITHOUT ANY WARRANTY; without
//   even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
//   PURPOSE. See the GNU General Public License for more details.
//  
//   You should have received a copy of the GNU General Public License along
//   with this program.If not, see<http:www.gnu.org/licenses/>.
//  
//  (3)CableLabs License
//   If you or the company you represent has a separate agreement with CableLabs
//   concerning the use of this code, your rights and obligations with respect
//   to this code shall be as set forth therein. No license is granted hereunder
//   for any other purpose.
//  
//   Please contact CableLabs if you need additional information or 
//   have any questions.
//  
//       CableLabs
//       858 Coal Creek Cir
//       Louisville, CO 80027-9750
//       303 661-9100
// COPYRIGHT_END

package org.cablelabs.impl.manager.signalling;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.util.Enumeration;
import java.util.Properties;
import java.util.Vector;

import org.davic.mpeg.sections.Section;

import org.cablelabs.impl.signalling.AbstractServiceEntry;
import org.cablelabs.impl.signalling.Ait;
import org.cablelabs.impl.signalling.AppEntry;
import org.cablelabs.impl.signalling.Xait;

/**
 * This is a simple <i>command-line</i> program that allows one to parse
 * individual AIT or XAIT sections. This isn't a unit test, but more of a smoke
 * test.
 * 
 * <p>
 * 
 * <pre>
 * Usage: TestParse <type> [file ...]
 * Where <type> is one of "ait" or "xait".
 * Options:
 * -help
 * </pre>
 * 
 * @author Aaron Kamienski
 * @see AitParser
 * @see XaitParser
 */
public class TestParse
{
    static final byte[] KEITH = { 0x74, (byte) 0xf0, (byte) 0xde, 0x00, 0x01, (byte) 0xc3, 0x00, 0x00, (byte) 0xf0,
            0x47, (byte) 0xae, 0x11, 0x01, 0x23, 0x45, (byte) 0xff, 0x55, 0x6e, 0x62, 0x6f, 0x75, 0x6e, 0x64, 0x20,
            0x31, 0x32, 0x33, 0x34, 0x35, (byte) 0xae, 0x0f, (byte) 0xba, (byte) 0x98, 0x76, (byte) 0xfe, 0x52, 0x65,
            0x62, 0x6f, 0x75, 0x6e, 0x64, 0x20, 0x42, 0x41, 0x39, (byte) 0xb1, 0x14, 0x00, 0x01, 0x02, 0x03, 0x04,
            0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13, 0x02, 0x0b, 0x00,
            0x01, 0x2a, (byte) 0xff, 0x00, 0x00, 0x00, 0x00, 0x04, (byte) 0xd2, 0x67, (byte) 0xf0, (byte) 0x8a, 0x00,
            0x00, 0x00, 0x01, 0x00, 0x02, 0x01, (byte) 0xf0, 0x3c, 0x00, 0x09, 0x05, 0x00, 0x01, 0x01, 0x00, 0x01,
            (byte) 0xff, 0x03, 0x2a, 0x01, 0x0f, 0x65, 0x6e, 0x67, 0x0b, 0x75, 0x6e, 0x62, 0x6f, 0x75, 0x6e, 0x64,
            0x20, 0x61, 0x70, 0x70, 0x03, 0x00, 0x04, 0x0e, 0x01, 0x2f, 0x00, 0x75, 0x6e, 0x62, 0x6f, 0x75, 0x6e, 0x64,
            0x58, 0x6c, 0x65, 0x74, (byte) 0xaf, 0x07, 0x01, 0x23, 0x45, 0x00, 0x00, 0x35, 0x7b, (byte) 0xb0, 0x03,
            0x12, 0x34, 0x03, 0x00, 0x00, 0x00, 0x01, 0x00, 0x03, 0x01, (byte) 0xf0, 0x3c, 0x00, 0x09, 0x05, 0x00,
            0x01, 0x01, 0x00, 0x01, (byte) 0xff, 0x03, 0x2a, 0x01, 0x0f, 0x65, 0x6e, 0x67, 0x0b, 0x75, 0x6e, 0x62,
            0x6f, 0x75, 0x47, 0x1f, (byte) 0xfc, 0x11, 0x6e, 0x64, 0x20, 0x61, 0x70, 0x70, 0x03, 0x00, 0x04, 0x0e,
            0x01, 0x2f, 0x00, 0x75, 0x6e, 0x62, 0x6f, 0x75, 0x6e, 0x64, 0x58, 0x6c, 0x65, 0x74, (byte) 0xaf, 0x07,
            (byte) 0xba, (byte) 0x98, 0x76, 0x00, 0x00, 0x35, 0x7b, (byte) 0xb0, 0x03, (byte) 0xab, (byte) 0xcd, 0x03 };

    static final byte[] KEITH2 = { 0x74, (byte) 0xf0, (byte) 0x99, 0x00, 0x01, (byte) 0xc9, 0x00, 0x00, (byte) 0xf0,
            0x12, (byte) 0xae, 0x10, 0x02, 0x00, 0x01, (byte) 0xff, 0x53, 0x69, 0x6d, 0x70, 0x6c, 0x65, 0x52, 0x65,
            0x64, 0x41, 0x70, 0x70, (byte) 0xf0, 0x7a, 0x00, 0x00, 0x00, 0x01, 0x00, 0x02, 0x01, (byte) 0xf0, 0x71,
            0x00, 0x09, 0x05, 0x00, 0x01, 0x01, 0x00, 0x01, (byte) 0xff, 0x03, 0x01, 0x01, 0x1a, 0x65, 0x6e, 0x67,
            0x16, 0x41, 0x75, 0x74, 0x6f, 0x53, 0x74, 0x61, 0x72, 0x74, 0x53, 0x69, 0x6d, 0x70, 0x6c, 0x65, 0x41, 0x70,
            0x70, 0x5f, 0x52, 0x65, 0x64, 0x02, 0x0b, 0x00, 0x01, 0x01, (byte) 0xff, 0x00, 0x00, 0x00, 0x00, 0x04,
            (byte) 0xd2, 0x00, 0x03, 0x00, 0x04, 0x2b, 0x01, 0x2f, 0x00, 0x63, 0x6f, 0x6d, 0x2e, 0x76, 0x69, 0x64,
            0x69, 0x6f, 0x6d, 0x2e, 0x74, 0x65, 0x73, 0x74, 0x2e, 0x78, 0x6c, 0x65, 0x74, 0x2e, 0x61, 0x70, 0x70, 0x73,
            0x2e, 0x53, 0x69, 0x6d, 0x70, 0x6c, 0x65, 0x54, 0x65, 0x73, 0x74, 0x58, 0x6c, 0x65, 0x74, (byte) 0xaf,
            0x07, 0x01, 0x00, 0x01, 0x00, 0x00, 0x35, 0x7b, (byte) 0xb0, 0x03, 0x12, 0x34, 0x03, 0x12, 0x3c, 0x4c,
            (byte) 0xf9, };

    static final byte[] KEITH3 = { 0x74, (byte) 0xf1, (byte) 0x9b, 0x00, 0x01, (byte) 0xc9, 0x00, 0x00, (byte) 0xf0,
            0x25, (byte) 0xae, 0x10, 0x02, 0x00, 0x01, (byte) 0xff, 0x53, 0x69, 0x6d, 0x70, 0x6c, 0x65, 0x52, 0x65,
            0x64, 0x41, 0x70, 0x70, (byte) 0xae, 0x11, 0x02, 0x00, 0x02, (byte) 0xfe, 0x53, 0x69, 0x6d, 0x70, 0x6c,
            0x65, 0x42, 0x6c, 0x75, 0x65, 0x41, 0x70, 0x70, (byte) 0xf1, 0x69, 0x00, 0x00, 0x00, 0x01, 0x00, 0x02,
            0x01, (byte) 0xf0, 0x71, 0x00, 0x09, 0x05, 0x00, 0x01, 0x01, 0x00, 0x01, (byte) 0xff, 0x03, 0x01, 0x01,
            0x1a, 0x65, 0x6e, 0x67, 0x16, 0x41, 0x75, 0x74, 0x6f, 0x53, 0x74, 0x61, 0x72, 0x74, 0x53, 0x69, 0x6d, 0x70,
            0x6c, 0x65, 0x41, 0x70, 0x70, 0x5f, 0x52, 0x65, 0x64, 0x02, 0x0b, 0x00, 0x01, 0x01, (byte) 0xff, 0x00,
            0x00, 0x00, 0x00, 0x04, (byte) 0xd2, 0x00, 0x03, 0x00, 0x04, 0x2b, 0x01, 0x2f, 0x00, 0x63, 0x6f, 0x6d,
            0x2e, 0x76, 0x69, 0x64, 0x69, 0x6f, 0x6d, 0x2e, 0x74, 0x65, 0x73, 0x74, 0x2e, 0x78, 0x6c, 0x65, 0x74, 0x2e,
            0x61, 0x70, 0x70, 0x73, 0x2e, 0x53, 0x69, 0x6d, 0x70, 0x6c, 0x65, 0x54, 0x65, 0x73, 0x74, 0x58, 0x6c, 0x65,
            0x74, (byte) 0xaf, 0x07, 0x02, 0x00, 0x01, 0x00, 0x00, 0x35, 0x7b, (byte) 0xb0, 0x03, 0x12, 0x34, 0x03,
            0x00, 0x00, 0x00, 0x01, 0x00, 0x03, 0x01, (byte) 0xf0, (byte) 0xe6, 0x00, 0x09, 0x05, 0x00, 0x01, 0x01,
            0x00, 0x01, (byte) 0xff, 0x03, 0x01, 0x01, 0x52, 0x65, 0x6e, 0x67, 0x15, 0x50, 0x72, 0x65, 0x73, 0x65,
            0x6e, 0x74, 0x53, 0x69, 0x6d, 0x70, 0x6c, 0x65, 0x41, 0x70, 0x70, 0x5f, 0x42, 0x6c, 0x75, 0x65, 0x66, 0x72,
            0x65, 0x18, 0x4c, 0x61, 0x20, 0x50, 0x72, 0x65, 0x73, 0x65, 0x6e, 0x74, 0x53, 0x69, 0x6d, 0x70, 0x6c, 0x65,
            0x41, 0x70, 0x70, 0x5f, 0x42, 0x6c, 0x75, 0x65, 0x67, 0x65, 0x72, 0x19, 0x44, 0x61, 0x73, 0x20, 0x50, 0x72,
            0x65, 0x73, 0x65, 0x6e, 0x74, 0x53, 0x69, 0x6d, 0x70, 0x6c, 0x65, 0x41, 0x70, 0x70, 0x5f, 0x42, 0x6c, 0x75,
            0x65, 0x02, 0x0b, 0x00, 0x01, 0x01, (byte) 0xff, 0x00, 0x00, 0x00, 0x00, 0x04, (byte) 0xd2, 0x00, 0x03,
            0x3d, 0x0f, 0x42, 0x61, 0x63, 0x6b, 0x47, 0x72, 0x6f, 0x75, 0x6e, 0x64, 0x3d, 0x62, 0x6c, 0x75, 0x65, 0x2c,
            0x4d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x3d, 0x50, 0x72, 0x65, 0x73, 0x65, 0x6e, 0x74, 0x20, 0x61, 0x70,
            0x70, 0x6c, 0x69, 0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x20, 0x2d, 0x20, 0x73, 0x69, 0x6d, 0x70, 0x6c, 0x65,
            0x41, 0x70, 0x70, 0x5f, 0x62, 0x6c, 0x75, 0x65, 0x04, 0x2b, 0x01, 0x2f, 0x00, 0x63, 0x6f, 0x6d, 0x2e, 0x76,
            0x69, 0x64, 0x69, 0x6f, 0x6d, 0x2e, 0x74, 0x65, 0x73, 0x74, 0x2e, 0x78, 0x6c, 0x65, 0x74, 0x2e, 0x61, 0x70,
            0x70, 0x73, 0x2e, 0x53, 0x69, 0x6d, 0x70, 0x6c, 0x65, 0x54, 0x65, 0x73, 0x74, 0x58, 0x6c, 0x65, 0x74,
            (byte) 0xaf, 0x07, 0x02, 0x00, 0x02, 0x00, 0x00, 0x35, 0x7b, (byte) 0xb0, 0x03, (byte) 0xab, (byte) 0xcd,
            0x03, (byte) 0xb0, 0x43, (byte) 0xa5, 0x55, };

    static final byte[] dummy = KEITH3;

    /**
     * Print usage() information.
     */
    private static void usage()
    {
        System.out.println("Usage: TestParse [options] <type> [file ...]");
        System.out.println("Where <type> is one of \"ait\" or \"xait\".");
        System.out.println("Options:");
        System.out.println("-help   : Print usage");
        System.out.println("-i      : Parse as InputStream and not sections");
        System.out.println("-s      : Parse as sections and not InputStream");
        System.out.println("-a      : Parse as hex ascii and not binary");
        System.out.println("-b      : Parse as binary and not hex ascii");
    }

    public static void main(String[] args)
    {
        Class ocapMain = org.cablelabs.impl.ocap.OcapMain.class;

        try
        {
            new TestParse(args);
        }
        catch (Exception e)
        {
            e.printStackTrace();
        }
    }

    private AitParser parser;

    private boolean asSections = false;

    private boolean asAscii = false;

    private Vector files = new Vector();

    /**
     * Execute based on given arguments.
     */
    TestParse(String[] args) throws Exception
    {
        for (int i = 0; i < args.length; ++i)
        {
            if (parser == null && "xait".equals(args[i]))
            {
                parser = new XaitParser(Xait.NETWORK_SIGNALLING);
            }
            else if (parser == null && "ait".equals(args[i]))
            {
                parser = new AitParser();
            }
            else if ("-help".equals(args[i]))
            {
                usage();
                System.exit(0);
            }
            else if ("-s".equals(args[i]))
            {
                asSections = true;
            }
            else if ("-i".equals(args[i]))
            {
                asSections = false;
            }
            else if ("-a".equals(args[i]))
            {
                asAscii = true;
                System.out.println("Unimplemented");
                System.exit(0);
            }
            else if ("-b".equals(args[i]))
            {
                asAscii = false;
                System.out.println("Unimplemented");
                System.exit(0);
            }
            else if (parser != null)
            {
                files.addElement(args[i]);
            }
            else
            {
                System.err.println("Unknown command: " + args[i]);
                usage();
                System.exit(-1);
            }
        }

        if (parser == null || files.size() < 1)
        {
            usage();
            System.exit(-1);
        }

        if (dummy != null)
        {
            FileOutputStream fos = new FileOutputStream((String) files.elementAt(0));
            fos.write(dummy);
            fos.close();

            parser.parse(new Section[] { new BasicSection(dummy) });
        }
        else if (!asSections)
        {
            for (Enumeration e = files.elements(); e.hasMoreElements();)
            {
                InputStream is = new FileInputStream((String) e.nextElement());

                /*
                 * if (asAscii) is = new HexAsciiInputStream(is);
                 */

                //parser.parse(is);
            }
        }
        else
        {
            Section[] data = new Section[files.size()];
            int i = 0;
            for (Enumeration e = files.elements(); e.hasMoreElements();)
            {
                File f = new File((String) e.nextElement());
                FileInputStream fis = new FileInputStream(f);
                int nbytes = (int) f.length();
                byte bytebuf[] = new byte[nbytes];

                int pos = 0;
                int n;
                while (nbytes > 0 && (n = fis.read(bytebuf, pos, nbytes)) != -1)
                {
                    pos += n;
                    nbytes -= n;
                }
                if (nbytes != 0) throw new IOException("Couldn't read entire file");

                data[i++] = new BasicSection(bytebuf);
            }

            parser.parse(data);
        }

        //parser.filterApps(new Properties(), new Properties());
        //dump(parser);
    }

    private void dump(Ait ait)
    {
        if (ait instanceof Xait)
            dumpXait((Xait) ait);
        else
            dumpAit(ait);
    }

    /**
     * Dumps the given AIT. Synchronized to avoid mixing print-outs.
     */
    private synchronized void dumpAit(Ait ait)
    {
        System.out.println("AIT parsed:");

        AppEntry[] apps = ait.getApps();
        System.out.println("  Contains " + apps.length + " apps:");
        for (int i = 0; i < apps.length; ++i)
        {
            System.out.println("[" + i + "]= " + apps[i]);
        }
        System.out.println();
    }

    /**
     * Dumps the given XAIT. Synchronized to avoid mixing print-outs.
     */
    private synchronized void dumpXait(Xait xait)
    {
        System.out.println("XAIT parsed:");

        AbstractServiceEntry[] services = xait.getServices();
        System.out.println("  Contains " + services.length + " services:");
        for (int i = 0; i < services.length; ++i)
        {
            System.out.println();
            System.out.println("[" + i + "]= " + services[i]);
            System.out.println("  Contains " + services[i].apps.size() + " apps:");

            int j = 0;
            for (Enumeration e = services[i].apps.elements(); e.hasMoreElements();)
            {
                System.out.println("   [" + j + "]= " + e.nextElement());
            }
        }
        System.out.println();
    }

}
