// COPYRIGHT_BEGIN
//  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER
//  
//  Copyright (C) 2008-2013, Cable Television Laboratories, Inc. 
//  
//  This software is available under multiple licenses: 
//  
//  (1) BSD 2-clause 
//   Redistribution and use in source and binary forms, with or without modification, are
//   permitted provided that the following conditions are met:
//        ·Redistributions of source code must retain the above copyright notice, this list 
//             of conditions and the following disclaimer.
//        ·Redistributions in binary form must reproduce the above copyright notice, this list of conditions 
//             and the following disclaimer in the documentation and/or other materials provided with the 
//             distribution.
//   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
//   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED 
//   TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
//   PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
//   HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
//   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
//   LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, 
//   DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY 
//   THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
//   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF 
//   THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//  
//  (2) GPL Version 2
//   This program is free software; you can redistribute it and/or modify
//   it under the terms of the GNU General Public License as published by
//   the Free Software Foundation, version 2. This program is distributed
//   in the hope that it will be useful, but WITHOUT ANY WARRANTY; without
//   even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
//   PURPOSE. See the GNU General Public License for more details.
//  
//   You should have received a copy of the GNU General Public License along
//   with this program.If not, see<http:www.gnu.org/licenses/>.
//  
//  (3)CableLabs License
//   If you or the company you represent has a separate agreement with CableLabs
//   concerning the use of this code, your rights and obligations with respect
//   to this code shall be as set forth therein. No license is granted hereunder
//   for any other purpose.
//  
//   Please contact CableLabs if you need additional information or 
//   have any questions.
//  
//       CableLabs
//       858 Coal Creek Cir
//       Louisville, CO 80027-9750
//       303 661-9100
// COPYRIGHT_END

#ifndef _MPEOS_HN_H_
#define _MPEOS_HN_H_

/** @file */

#ifdef __cplusplus
extern "C"
{
#endif

#include "mpe_types.h"  /* Resolve basic type references. */
#include "mpe_error.h"
#include "mpeos_event.h"
#include "mpeos_socket.h"
#include "mpeos_media.h"
#include "mpeos_disp.h"
#include "mpeos_dvr.h"
#include "os_hn.h"


/*****************************************************************************/
/***                                                                       ***/
/***                    PLAYER/SERVER SHARED STRUCTURES                    ***/
/***                                                                       ***/
/*****************************************************************************/


/**
 * Opaque handle representing a home networking streaming session.
 * Used by both player and server.
 */
typedef struct _mpe_HnStreamSessionH
{
    int unused1; /**< Unused */
}
*mpe_HnStreamSession;

/**
 * Opaque handle representing a home networking play back session.
 * Used by both player and server.
 */
typedef struct _mpe_HnPlaybackSessionH
{
    int unused1; /**< Unused */
}
*mpe_HnPlaybackSession;

/**
 * HN related events.
 *
 * The events listed below should be generated by the underlying HN Platform
 * implementation and sent to the event queue supplied by the stack via
 * mpeos_hnStreamOpen() call. Refer to the mpe_EventQueue parameter for more
 * details.
 *
 * The event queue receives both session-related and playback-related events.
 * The following types of events are defined:
 **/
typedef enum mpe_HnEvent
{
    /**
     * HN Events start at 100.
     */
    MPE_HN_EVENT_BASE = 100,

    /**
    <pre>
     * Sent during SERVER or PLAYER playback sessions when the
     * playback rate POSITIVE and:
     * SERVER: The end of available streamable content is reached, such as the
     *         end of one segment of a recording.
     * SERVER: Requested byterange or timerange has been sent.
     * PLAYER: Transmission completes without an error.
     * PLAYER: Zero-length transmission-terminating HTTP chunk is received.
     * PLAYER: The number of bytes specified by "Content-Length" HTTP header is
     *         received.
     *
     * optionalEventData1 - N/A
     * optionalEventData2 - N/A
     * optionalEventData3 - N/A
    </pre>
     **/
    MPE_HN_EVT_END_OF_CONTENT,

    /**
    <pre>
     * Sent during SERVER or PLAYER playback sessions when the
     * playback rate is NEGATIVE and:
     * SERVER: The end of available streamable content is reached, such as the
     *         end of one segment of a recording.
     * SERVER: Requested byterange or timerange has been sent.
     * PLAYER: Transmission completes without an error.
     * PLAYER: Zero-length transmission-terminating HTTP chunk is received.
     * PLAYER: The number of bytes specified by "Content-Length" HTTP header is
     *         received.
     *
     * optionalEventData1 - N/A
     * optionalEventData2 - N/A
     * optionalEventData3 - N/A
    </pre>
     **/
    MPE_HN_EVT_BEGINNING_OF_CONTENT,

    /**
    <pre>
     * Sent in response to an mpeos_hnStreamClose() call. It
     * represents the successful closing and shutdown of a streaming session for
     * both SERVER and PLAYER.
     *
     * optionalEventData1 - N/A
     * optionalEventData2 - N/A
     * optionalEventData3 - N/A
    </pre>
     **/
    MPE_HN_EVT_SESSION_CLOSED,

    /**
    <pre>
     * Sent in response to a mpeos_hnStreamOpen() call. It represents
     * the successful initialization and opening of a streaming session for both
     * SERVER and PLAYER.
     *
     * optionalEventData1 - N/A
     * optionalEventData2 - N/A
     * optionalEventData3 - N/A
    </pre>
     **/
    MPE_HN_EVT_SESSION_OPEN,

    /**
    <pre>
     * Sent in response to an mpeos_hnPlaybackStart() call. It
     * indicates successful allocation of resources such as:
     * SERVER: recording, tuner, TSB or file.
     * PLAYER: socket, A/V decoding and presentation device.
     *
     * For PLAYER playback, it also includes formulation and sending of the initial
     * HTTP request, reception of a successful HTTP response and verification of
     * received HTTP response header parameters.
     *
     * For PLAYER playback, this event can also be sent during an on-going playback
     * to indicate that the underlying platform has detected a change in 2D/3D
     * content presentation format. Such event is preceeded by an
     * MPE_3D_FORMAT_CHANGED event.
     *
     * For PLAYER playback, note that the mpeos_media event MPE_3D_FORMAT_CHANGED
     * can also be sent to an HN event queue, when a change in 2D/3D media
     * presentation is detected. Refer to mpeos_media.h documentation for more
     * details.
     *
     * optionalEventData1 - (optional) mpe_PresentingReason value. Refer to mpeos_media.h for more details.
     * optionalEventData2 - N/A
     * optionalEventData3 - N/A
    </pre>
     **/
    MPE_HN_EVT_PLAYBACK_START = MPE_CONTENT_PRESENTING, // 0x05

    /**
    <pre>
     * For SERVER playback, this event indicates the platform's inability to send
     * the requested content due to socket issues, such as client disconnection.
     *
     * For PLAYER playback, this event is sent in response to an mpeos_hnPlaybackStop() call.
     *
     * optionalEventData1 - N/A
     * optionalEventData2 - N/A
     * optionalEventData3 - N/A
    </pre>
     **/
    MPE_HN_EVT_PLAYBACK_STOPPED = MPE_HN_EVENT_BASE + 6,

    /**
    <pre>
     * Sent whenever authorization is no longer valid for a streaming
     * session. Any problem that occurs during DTCP/IP decryption of incoming
     * content on the PLAYER or during DTCP/IP encryption of outgoing content on
     * the server should be signalled via this event.
     *
     * optionalEventData1 - N/A
     * optionalEventData2 - N/A
     * optionalEventData3 - N/A
    </pre>
     **/
    MPE_HN_EVT_SESSION_NO_LONGER_AUTHORIZED = MPE_HN_EVENT_BASE + 7,

    /**
    <pre>
     * Sent upon initial setup or during ongoing streaming and playback sessions when the
     * session or playback fails unexpectedly on both server and player. An error
     * code will be set describing the error condition. Examples include:
     * The PLAYER fails to setup or decode an incoming transmission due to stream format issues.
     * The SERVER fails to setup or encode outgoing transmission due to internal resource problems.
     *
     * optionalEventData1 - N/A
     * optionalEventData2 - N/A
     * optionalEventData3 - N/A
    </pre>
     **/
    MPE_HN_EVT_FAILURE = MPE_FAILURE_UNKNOWN, // 0x06

    /**
    <pre>
     * For SERVER playback, this event indicates the platform's inability to send
     * the requested content for the supplied connection stalling timeout seconds.
     *
     * optionalEventData1 - N/A
     * optionalEventData2 - N/A
     * optionalEventData3 - N/A
    </pre>
     **/
    MPE_HN_EVT_INACTIVITY_TIMEOUT = MPE_HN_EVENT_BASE + 8,

}
mpe_HnEvent;

/**
 * Valid return codes for all porting layer functions:
 *
 * MPE_HN_ERR_NOERR - Operation completed successfully.
 **/
#define    MPE_HN_ERR_NOERR              MPE_SUCCESS
 /**
 * MPE_HN_ERR_INVALID_PARAM - One of the input parameters is invalid.
 **/
#define    MPE_HN_ERR_INVALID_PARAM      MPE_HN_ERR_NOERR+1
 /**
 * MPE_HN_ERR_OS_FAILURE - Encoder/decoder issues.
 *                         Memory issues.
 **/
#define    MPE_HN_ERR_OS_FAILURE         MPE_HN_ERR_NOERR+2
 /**
  * MPE_HN_ERR_CONTENT - Content type is not supported.
  *                      Content no longer exists.
  *                      Server authorization problems.
  **/
#define    MPE_HN_ERR_CONTENT            MPE_HN_ERR_NOERR+3
 /**
  * MPE_HN_ERR_NOT_IMPLEMENTED - HN functionality has not been implemented.
  **/
#define    MPE_HN_ERR_NOT_IMPLEMENTED    MPE_HN_ERR_NOERR+4

/**
 * DLNA Profile IDs and mime types. Defines limits for maximum string lengths
 * that are used to convey the information in string form between the RI stack
 * and underlying HN platform implementation.
 *
 * For more information, please refer to the following specifications:
 * - DLNA Guidelines Volume 2: Media Format Profiles
 * - OpenCable Home Networking specification
 * <a href="http://www.cablelabs.com/specifications/">OC-SP-HNP2.0: 5.8 Content Formats</a>
 */

#define    MPE_HN_MAX_DLNA_PROFILE_ID_STR_SIZE    OS_HN_MAX_DLNA_PROFILE_ID_STR_SIZE
///< See <a href="https://community.cablelabs.com/svn/OCAPRI/trunk/ri/RI_Stack/mpe/os/RI_Common/include/os_hn.h">os_hn.h</a>
#define    MPE_HN_MAX_MIME_TYPE_STR_SIZE          OS_HN_MAX_MIME_TYPE_STR_SIZE
///< See <a href="https://community.cablelabs.com/svn/OCAPRI/trunk/ri/RI_Stack/mpe/os/RI_Common/include/os_hn.h">os_hn.h</a>
#define    MPE_HN_MAX_PLAYSPEED_STR_SIZE          OS_HN_MAX_PLAYSPEED_STR_SIZE
///< See <a href="https://community.cablelabs.com/svn/OCAPRI/trunk/ri/RI_Stack/mpe/os/RI_Common/include/os_hn.h">os_hn.h</a>
/**
 * Maximum MAC address size. Format is as follows: "12:34:56:78:9A:BC\0".
 * See mpeos_hnGetMacAddress() for more details.
 **/
#define    MPE_HN_MAX_MAC_ADDRESS_STR_SIZE    18

/**
 * This enumeration is used in mpe_HnStreamParams structure defined below. It
 * allows the stack to differentiate between player and server method calls.
 **/
typedef enum _mpe_HnStreamType
{
    MPE_HNSTREAM_MEDIA_SERVER_HTTP = 1,
    MPE_HNSTREAM_MEDIA_PLAYER_HTTP = 2
}
mpe_HnStreamType;

/**
 * Opaque data structure that is passed to mpeos_streamOpen and
 * mpeos_streamGetInfo calls. The requestType field allows the HN platform
 * implementation to differentiate between player and server calls.
 *
 * Associated server structure is defined in mpe_HnStreamParamsMediaServerHttp.
 * Associated player structure is defined in mpe_HnStreamParamsMediaPlayerHttp.
 **/
typedef struct _mpe_HnStreamParams
{
    mpe_HnStreamType requestType;
    void * streamParams;
}
mpe_HnStreamParams;

/**
 * This enumeration is used in mpe_HnPlaybackParams structure defined below. It
 * allows the stack to differentiate between player and server method calls.
 **/
typedef enum _mpe_HnPlaybackType
{
    MPE_HNPLAYBACK_MEDIA_SERVER_HTTP = 1,
    MPE_HNPLAYBACK_MEDIA_PLAYER_HTTP
}
mpe_HnPlaybackType;

/**
 * Opaque data structure that is passed to mpeos_playbackStart call. The
 * playbackType field allows the HN platform implementation to differentiate
 * between player and server calls.
 *
 * Associated server struct is defined in mpe_HnPlaybackParamsMediaServerHttp.<br>
 * Associated player struct is defined in mpe_HnPlaybackParamsMediaPlayerHttp.
 **/
typedef struct _mpe_HnPlaybackParams
{
    mpe_HnPlaybackType playbackType;
    void * playbackParams;
}
mpe_HnPlaybackParams;

/**
 * The following structure is used to convey the decoded/desired copy control
 * information to the underlying HN platform implementation. Refer to DTCP V1SE
 * specification, section V1SE.7 for more information.
 *
 **/
typedef struct _mpe_HnPlaybackCopyControlInfo
{
    uint16_t pid;       ///< PID of either PMT or an elementary stream.

    mpe_Bool isProgram; ///< Specifies whether the PID above refers to a PMT (TRUE) or an
                        ///< elementary stream (FALSE). If PMT, the descriptor is carried in
                        ///< the program_info loop of the PMT. If elementary stream, the
                        ///< descriptor is carried in the ES_info loop of the PMT.

    mpe_Bool isAudio;   ///< TRUE for DTCP_audio_descriptor, FALSE for DTCP_descriptor.

    uint8_t cci;        ///< Value of the CCI byte.
                        ///< Defined in <a href="http://www.cablelabs.com/specifications/">OC-SP-CCCP2.0 specification</a>,
                        ///< Table 9.1-1 CCI Bit Assignments.
}
mpe_HnPlaybackTransportCCI;



/*****************************************************************************/
/***                                                                       ***/
/***                           SERVER STRUCTURES                           ***/
/***                                                                       ***/
/*****************************************************************************/

/**
 * <a href="http://www.cablelabs.com/specifications/">OC-SP-HNP2.0 specification</a>,
 * section 5.6.1.6 FrameTypesInTrickMode. Tells the
 * underlying HN server implementation what the remote HN player has requested
 * as preference for frame type encoding in trick play.
 **/
typedef enum _mpe_HnHttpHeaderFrameTypesInTrickMode
{
    MPE_HN_TRICK_MODE_FRAME_TYPE_I = 1,
    MPE_HN_TRICK_MODE_FRAME_TYPE_IP,
    MPE_HN_TRICK_MODE_FRAME_TYPE_ALL,
    MPE_HN_TRICK_MODE_FRAME_TYPE_NONE = 0xFFFF
}
mpe_HnHttpHeaderFrameTypesInTrickMode;

/**
 * <a href="http://www.cablelabs.com/specifications/">OC-SP-HNP2.0 specification</a>,
 * section 5.6.1.2 ChunkEncodingMode. Tells the
 * underlying HN server implementation what the remote HN player has requested
 * as preference for receiving chunk-encoded HTTP content.
 *
 * For OTHER mode, the underlying HN server implementation can encode chunks of
 * data in implementation specific fashion, as long as the streaming begins at
 * decoder friendly point. Refer to DLNA Guidelines Volume 1: Architectures and
 * Protocols, Req [7.4.40.6].
 *
 * For NONE mode, the underlying HN server implementation should not apply any
 * chunk encoding and send the data verbatim over socket.
 **/
typedef enum _mpe_HnHttpHeaderChunkedEncodingMode
{
    MPE_HN_CHUNKED_ENCODING_MODE_GOP = 1,
    MPE_HN_CHUNKED_ENCODING_MODE_FRAME,
    MPE_HN_CHUNKED_ENCODING_MODE_OTHER,
    MPE_HN_CHUNKED_ENCODING_MODE_NONE = 0xFFFF
}
mpe_HnHttpHeaderChunkedEncodingMode;

/**
 * The following enumeration is used to differentiate between different content
 * descriptions that can be passed for DLNA profile ID queries, mime type
 * queries as well as for HN server playback initiation.
 *
 * Refer to the field definitions that follow for more details concerning each
 * content description.
 */
typedef enum _mpe_HnStreamContentLocation
{
    MPE_HN_CONTENT_LOCATION_LOCAL_MSV_CONTENT = 1,
    MPE_HN_CONTENT_LOCATION_LOCAL_FILE_CONTENT,
    MPE_HN_CONTENT_LOCATION_LOCAL_TSB,
    MPE_HN_CONTENT_LOCATION_LOCAL_TUNER,
    MPE_HN_CONTENT_LOCATION_LOCAL_VIDEO_DEVICE,
    MPE_HN_CONTENT_LOCATION_UNKNOWN = 0xFFFF
}
mpe_HnStreamContentLocation;

/**
 * This following structure should be referenced by the
 * MPE_HN_CONTENT_LOCATION_LOCAL_MSV_CONTENT discriminator.
 *
 * It defines the content name and source storage media volume for
 * referencing DVR recordings.
 */
typedef struct _mpe_HnStreamLocalSVContentDescription
{
    char * contentName;             ///< Name of (local) recoreded content item.
    mpe_MediaVolume volumeHandle;   ///< Where it is stored...
}
mpe_HnStreamLocalSVContentDescription;

/**
 * This following structure should be referenced by the
 * MPE_HN_CONTENT_LOCATION_LOCAL_FILE_CONTENT discriminator.
 *
 * It defines name and path for personal content items that can be streamed.
 *
 * NOTE: This content type is currently not supported.
 */
typedef struct _mpe_HnStreamAppContentDescription
{
    char * contentName;    ///< Name for personal content item.
    char * pathName;       ///< (File) path for personal content item.
}
mpe_HnStreamAppContentDescription;

/**
 * This following structure should be referenced by the
 * MPE_HN_CONTENT_LOCATION_LOCAL_TSB discriminator.
 */
typedef struct _mpe_HnStreamTSBContentDescription
{
    mpe_DvrTsb tsb;    ///< Time-shift buffer whose contents can be streamed in real time
                       ///< over the home network.
}
mpe_HnStreamTSBContentDescription;

/*
 * Media stream types.
 * Identifies the type of data carried on a particular PID.  These values
 * correspond to constants defined in the Java class MediaStreamType.
 */
typedef enum mpe_HnMediaStreamType
{
    MPE_HN_MEDIA_UNKNOWN = 0,
    MPE_HN_MEDIA_VIDEO = 1,
    MPE_HN_MEDIA_AUDIO = 2,
    MPE_HN_MEDIA_DATA = 3,
    MPE_HN_MEDIA_SUBTITLES = 4,
    MPE_HN_MEDIA_SECTIONS = 5,
    MPE_HN_MEDIA_PCR = 6,
    MPE_HN_MEDIA_PMT = 7
} mpe_HnMediaStreamType;

/**
 * Information for a single PID.
 */
typedef struct _mpe_HnPidInfo
{
    /** Type of data carried on this PID */
    mpe_HnMediaStreamType streamType;

    /** Original PID value as delivered over the network */
    int16_t pid;

    /**
     * Specific format of media carried on this PID as originally
     * delivered over the network.
     */
    mpe_SiElemStreamType eltStreamType;
} mpe_HnPidInfo;

/**
 * This following structure should be referenced by the
 * MPE_HN_CONTENT_LOCATION_LOCAL_TUNER discriminator.
 *
 * It defines the tuner whose contents can be streamed in real time over the
 * home network. The in-band tunerId starts at index 1. A non-0 ltsid value
 * identifies the Local Transport Stream ID carrying the content.
 * The pidCount and pids define the pids that will be included from the tuner
 * into the live stream SPTS.
 *
 */
typedef struct _mpe_HnStreamTunerContentDescription
{
    uint32_t tunerId;
    uint32_t freq;
    uint8_t ltsid;
    uint32_t pidCount;
    mpe_HnPidInfo *pids;
}
mpe_HnStreamTunerContentDescription;

/**
 * This following structure should be referenced via the
 * MPE_HN_CONTENT_LOCATION_LOCAL_VIDEO_DEVICE discriminator.
 *
 * It defines the video device to be used as the content source. When this
 * content type is used as a server-side streaming data source, content
 * rendered to the given video device shall be streamed out via the associated
 * streaming session. This includes content rendered via mpeos_dvrPlayback
 * sessions or mpe_MediaDecodeSession. Trick mode rendering must also be
 * streamed, with allowance for diminished quality and/or framerate.
 */
typedef struct _mpe_HnStreamVideoDeviceContentDescription
{
    mpe_DispDevice videoDevice;
}
mpe_HnStreamVideoDeviceContentDescription;

/**
 * This structure allows the platform to describe its transformational capabilities for
 * HN-streamable content.
 *
 * A element of this structure defines a content transformation  of any content natively
 * stored in a format compatible with the designated sourceProfile to the given
 * transformedProfile with the provided restrictions. All audio streams present
 * in the source content must be present in the transformed representation in audio format(s)
 * required/appropriate for the profile.
 *
 * Note that for the following (segmented) profiles, additional requirements apply.
 * Content in these formats must be supplied in segments, with each segment representing
 * the same duration of time, except for the last segment. Each segment must represent a
 * whole number of seconds from 2 to 30 seconds. (Note: The number of segments for a given
 * profile is determined using mpeos_hnServerGetSegmentInfo()).
 *
 * DASH_AVC_TS_ISO
 * DASH_AVC_MP4
 *
 * Also, transformed segment representations conforming to profile DASH_AVC_TS_ISO
 * must also be compliant with HLS media file/segment requirements.
 * And transformed segment representations conforming to profile DASH_AVC_MP4
 * must also be compliant with IIS SmoothStreaming AVC/H.264 fragment requirements.
 *
 **/
typedef struct _mpe_hnContentTransformation
{
    int32_t id;                         ///< The numerical ID for the transformation
    char sourceProfile[MPE_HN_MAX_DLNA_PROFILE_ID_STR_SIZE];
                                        ///< The source DLNA profile that can be converted
    char transformedProfile[MPE_HN_MAX_DLNA_PROFILE_ID_STR_SIZE];
                                        ///< The transformed DLNA profile
    int32_t bitrate;                    ///< The maximum (fixed) bitrate for this transformation (in kbps)
    int32_t width;                      ///< The maximum horizontal resolution for this transformation
    int32_t height;                     ///< The maximum vertical resolution for this transformation
    mpe_Bool progressive;               ///< The supported frame format (progressive/interlaced)
} mpe_hnContentTransformation;

/**
 * This structure allows the platform to describe the segmented characteristics for a piece
 * of content that can be represented in a segmented format.
 **/
typedef struct _mpe_hnSegmentedContentInfo
{
    uint16_t segmentDurationSec;      ///< The duration of each content segment, in whole segments
    uint32_t numberOfSegments;        ///< The number of segments required to stream the content
    uint64_t availabilityTimeMs;      ///< The availability time of the first segment (in
                                      ///< milliseconds since the Unix epoch, Jan 1 1970, 00:00:00
                                      ///< UTC). Each successive segment will be presumed to have
                                      ///< an availability time equal to this value plus the sum of
                                      ///< all segment durations preceding the segment
} mpe_hnSegmentedContentInfo;

/**
 * Structure representing the server-side streaming parameters.
 *
 * The incoming streaming client requests are processed and validated by the RI
 * stack code. Once the validation succeeds (i.e. the HTTP headers are verified
 * to be valid and any requested options are found to be satisfiable, such us
 * the seek ranges, playspeeds, DLNA profile IDs, etc.), the stack will call
 * the mpeos_HnStreamOpen() with the structure defined below to initiate the
 * data transfer to the remote HN player.
 *
 * Every valid incoming streaming request will be associated with one streaming
 * session. Playspeed change requests or seek requests for the same resource
 * coming from the same remote HN player will still result in multiple calls to
 * mpeos_hnStreamOpen(). There is a one-to-one association between sockets on
 * which the requests originate and opened streaming sessions.
 *
 * The following parameters: currentDecodePTS, chunkedEncodingMode,
 * maxGOPsPerChunk, maxFramesPerGOP, useServerSidePacing,
 * frameTypesInTrickModes and maxTrickModeBandwidth are optional and come from
 * the <a href="http://www.cablelabs.com/specifications/">OC-SP-HNP2.0 specification.</a>
 * Refer to section 5.6.1 HTTP Headers for more details.
 *
 **/
typedef struct _mpe_HnStreamParamsMediaServerHttp
{
    uint32_t connectionId;              ///< his parameter can be used by the underlying HN server
                                        ///< platform implementation to associate and serve requests
                                        ///< coming from the same remote HN player. Refer to DLNA
                                        ///< Guidelines, Volume 1: Architectures and Protocols, section
                                        ///< Basic Connection Management (BCM) Guidelines, [7.3.84],
                                        ///< [7.3.85], and [7.3.87].

    char * dlnaProfileId;               ///< DLNA media format for the stream session that indicates how
                                        ///< the content should be streamed out. Refer to DLNA Guidelines
                                        ///< Volume 2: Media Format Profiles for more information. The
                                        ///< actual profile ID string can be prefixed with "DTCP_" string
                                        ///< to indicate that DTCP/IP encryption should be applied during
                                        ///< this streaming session. In that case, the PCP encapsulation
                                        ///< should be applied and DTCP descriptors should be embedded in
                                        ///< the outgoing stream.

    char * mimeType;                    ///< Mime type for the stream session that indicates a choice of a
                                        ///< mime type as some DLNA profile IDs could have multiple mime types
                                        ///< associated with them. The stack will never use
                                        ///< "application/x-dtcp1" content format here; in case of DTCP/IP
                                        ///< transmissions, the actual "CONTENTFORMAT" value will be conveyed
                                        ///< here. Refer to DTCP/IP specification, V1SE.10 Recommendations.

    mpe_Socket socket;                  ///< Socket handle to be used by the underlying HN server platform
                                        ///< implementation for sending out the actual content data.

    mpe_HnHttpHeaderChunkedEncodingMode chunkedEncodingMode; ///< Requested mode for chunked encoding, if desired.

    int64_t maxTrickModeBandwidth;      ///< Maximum rate in bits/sec of the outgoing content; -1 if unspecified.

    int64_t currentDecodePTS;           ///< Remote HN player's current decoder timestamp; -1 if unspecified.

    int8_t maxGOPsPerChunk;             ///< Requested maximum number of Group-of-Pictures units inside HTTP chunk;
                                        ///< -1 if unspecified.

    int8_t maxFramesPerGOP;             ///< Requested maximum number of frames per GOP; -1 if unspecified.

    mpe_Bool useServerSidePacing;       ///< Requested serverside paced streaming.

    mpe_HnHttpHeaderFrameTypesInTrickMode frameTypesInTrickModes; ///< Requested frame types for trick modes.

    int32_t connectionStallingTimeoutMS;  ///< Max amount of elapsed time in seconds to keep the connection open
                                          ///< when unable to send data; -1 if unspecified or connection stalling is
                                          ///< not supported for this content

}
mpe_HnStreamParamsMediaServerHttp;

/**
 * Structure representing the server-side playback parameters.
 *
 * At any given time, a streaming session will have at most one single active
 * playback. For non-segmented content, with uniform copy protection setting,
 * there will only exist one single playback during a lifecycle of an active
 * streaming session.
 *
 * For segmented content (some recordings or TSBs), or content that contains
 * changing copy protection settings, a streaming session will be associated
 * with a series of playbacks. Still, at any given point in time of a streaming
 * session, there will only exist one single active playback.
 *
 * Both specified byte positions will always be passed in network byte domain.
 * For playbacks that are part of DTCP-enabled server streaming sessions, this
 * means that requested positions already account for PCP-encapsulation.
 *
 * For MPE_HN_CONTENT_LOCATION_LOCAL_VIDEO_DEVICE content location type, it is
 * the responsibility of the underlying HN server platform implementation to
 * correctly convey and update CCI settings from sources when they are
 * supplying the stream content to the video device. In this case, the
 * cciDescSize and cciDescData parameters should be ignored.
 *
 **/
typedef struct _mpe_HnPlaybackParamsMediaServerHttp
{
    mpe_HnStreamContentLocation contentLocation;    ///< Supplies the type of the content description that follows.

    void * contentDescription;                      ///< A reference to a recording, a TSB, personal content
                                                    ///< item, or a tuner.

    float playspeedRate;                            ///< Requested playspeed rate. Normal (1x) or trick-play (!=1x).

    mpe_Bool useTimeOffset;                         ///< True if time offset values are to be used (as opposed
                                                    ///< to byte offsets)

    int64_t startBytePosition;                      ///< Start streaming data from this byte position. If -1, use
                                                    ///< default start media time appropriate for dlnaProfileId
                                                    ///< associated with the underlying streaming session. In
                                                    ///< particular, this value will be -1 for
                                                    ///< MPE_HN_CONTENT_LOCATION_LOCAL_VIDEO_DEVICE.

    int64_t endBytePosition;                        ///< End streaming when this byte position is reached. If -1,
                                                    ///< stream until no more content is available in the direction
                                                    ///< of playspeedRate.

    int64_t startTimePosition;                      ///< Start streaming data from this time position. If -1, use
                                                    ///< default start media time appropriate for dlnaProfileId
                                                    ///< associated with the underlying streaming session. In
                                                    ///< particular, this value will be -1 for
                                                    ///< MPE_HN_CONTENT_LOCATION_LOCAL_VIDEO_DEVICE.

    int64_t endTimePosition;                        ///< End streaming when this time position is reached. If -1,
                                                    ///< stream until no more content is available in the direction
                                                    ///< of playspeedRate.

    uint32_t cciDescSize;                           ///< Number of CCI descriptor insertions that need to be performed.

    mpe_HnPlaybackTransportCCI* cciDescData;        ///< Pointer to an allocated structure that conveys per-PID copy
                                                    ///< control information for DTCP descriptor embedding in the
                                                    ///< outgoing stream. Allocated memory equals
                                                    ///< cciDescSize * sizeof(mpe_HnPlaybackTransportCCI).

    mpe_hnContentTransformation * transformation;   ///< Pointer to an allocated structure that conveys the requested
                                                    ///< transformed version of the resource. If the native version
                                                    ///< of the content is being streamed, this will be NULL.

    uint16_t segmentNumber;                         ///< For segmented content, the segment number to stream.
                                                    ///<  When provided, playspeedRate is ignored.
}
mpe_HnPlaybackParamsMediaServerHttp;



/*****************************************************************************/
/***                                                                       ***/
/***                           PLAYER STRUCTURES                           ***/
/***                                                                       ***/
/*****************************************************************************/

/**
 * Structure representing the audio and video PID stream parameters, which
 * allows the stack to communicate to the underlying HN player implementation
 * a set of A/V PIDs which have been either:
 * - Extracted from the incoming MPEG-2 transport stream via SI HN PAT/PMT
 *   discovery process, or
 * - Sent by the remote HN server using the optional AVStreamParameters HTTP
 *   header. Refer to <a href="http://www.cablelabs.com/specifications/">OC-SP-HNP2.0</a>,
 *   section 5.6.1.9 for more details.
 *
 * To specify default video and audio PIDs, a value of 0xFFFF will be used.
 **/
typedef struct _mpe_HnHttpHeaderAVStreamParameters
{
    uint16_t videoPID;  ///< Packet id for video
    uint32_t videoType; ///< Must adhere to stream type defined in ISO/IEC 13818-1:2000
    uint16_t audioPID;  ///< Packet id for audio
    uint32_t audioType; ///< Must adhere to stream type defined in ISO/IEC 13818-1:2000
}
mpe_HnHttpHeaderAVStreamParameters;

/**
 * Structure representing the player-side streaming parameters.
 *
 * The stack will call mpeos_hnStreamOpen() with the following structure to
 * initiate HN player streaming from remote HN server. The underlying platform
 * implementation should allocate needed resources for this session and be able
 * to accept playback requests.
 *
 * The HN platform should not attempt to make any connections at this time,
 * as the mpeos_hnPlaybackStart() call supplies the missing parts of the
 * playback request and then makes it possible to construct HTTP request(s) to
 * retrieve content from the remote HN server.
 *
 * If the remote HN server is unable to supply enough information about the
 * supported DLNA profile IDs for the stack to make a correct choice about
 * which profile to select for streaming, then a NULL value can be passed for
 * dlnaProfileId. In this case, the underlying HN platform implementation
 * should make a best effort attempt to determine the format of the incoming
 * stream and enable audio/video presentation, if possible.
 *
 **/
typedef struct _mpe_HnStreamParamsMediaPlayerHttp
{
    uint32_t connectionId;  ///< This parameter can be used by the underlying HN player
                            ///< platform implementation to associate requests coming from the
                            ///< same stack presentation session. If this parameter is 0, then
                            ///< the connectionId should be assigned by the remote HN server.
                            ///< Refer to DLNA Guidelines, Volume 1: Architectures and
                            ///< Protocols, section Basic Connection Management (BCM)
                            ///< Guidelines, [7.3.84], [7.3.85], and [7.3.87].

    char * uri;             ///< This is a URI picked from a list of server-supplied resource element
                            ///< choices. The stack incorporates the HN platform implementation
                            ///< preferences for DLNA profile IDs based on the return values from
                            ///< mpeos_hnPlayerGetDLNAProfileIDStr() to select the best available
                            ///< streaming media format.

    char * dlnaProfileId;   ///< DLNA media format for the stream session that indicates the
                            ///< type of content that the HN player implementation will
                            ///< receive. Refer to DLNA Guidelines Volume 2: Media Format
                            ///< Profiles for more information. The actual profile ID string
                            ///< can be prefixed with "DTCP_" string to indicate that DTCP/IP
                            ///< decryption will be applied to the incoming stream.

    char * mimeType;        ///< Mime type for the stream session that indicates the type of
                            ///< content that the HN player implementation will receive. The stack
                            ///< will never use "application/x-dtcp1" content format here; in case
                            ///< of DTCP/IP transmissions, the actual "CONTENTFORMAT" value will
                            ///< be conveyed here. Refer to DTCP/IP specification,
                            ///< V1SE.10 Recommendations.

    char * host;            ///< IP host address of the remote HN server.

    uint32_t port;          ///< IP port of the remote HN server.

    char * dtcp_host;       ///< DTCP/IP AKE IP host address of the remote HN server. This
                            ///< parameter can be NULL if the selected DLNA profile ID does not
                            ///< start with "DTCP_".

    uint32_t dtcp_port;     ///< DTCP/IP AKE IP port of the remote HN server.
}
mpe_HnStreamParamsMediaPlayerHttp;

/**
 * Structure representing the player-side playback parameters.
 *
 * The underlying platform implementation should construct the proper HTTP
 * headers and add any other optional fields that might be necessary to make
 * the HTTP request complete. This might include chunk encoding modes, byte
 * seek ranges, media time ranges, playspeeds, GOPs/chunk, frames/GOP limits
 * and others. Refer to DLNA Guidelines Volume 1: Architectures and Protocols
 * and <a href="http://www.cablelabs.com/specifications/">OC-SP-HNP2.0 specification</a>
 * for more details.
 *
 * In particular, the implementation should make efforts to determine the
 * optimal trick mode mechanism, depending on both the remote server and
 * underlying platform player capabilities. This includes range-based seeking
 * (client-side trick modes), time-based seeking (server-side trick-modes) and
 * and server-side pacing considerations. Refer to DLNA Guidelines document for
 * more details.
 *
 * This might require sending several HTTP GET or HEAD requests to query
 * the remote server for its streaming (i.e. HTTP 1.0 vs 1.1) and trick play
 * capabilities, prior to the start of actual data transmission.
 *
 * For example initialmediaTimeNS might result in several initial byte range
 * requests that would permit the local platform implementation to find the
 * desired media time if the server does not support the TimeSeekRange.dlna.org
 * headers.
 *
 * For trick mode playback (non 1.0x request), this request might be translated
 * into a set of byte range requests, time seek range requests, playspeed
 * requests, or a combination of those, depending on the remote server and
 * underlying player platform capabilities. Refer to DLNA Guidelines for more
 * details.
 *
 **/
typedef struct _mpe_HnPlaybackParamsMediaPlayerHttp
{
    mpe_HnHttpHeaderAVStreamParameters avStreamParameters;  ///< Specifies audio and video PID values to use. If default
                                                            ///< values are used, this indicates that the stack is
                                                            ///< initiating a playback session to perform SI HN PAT/PMT
                                                            ///< discovery.

    mpe_DispDevice videoDevice;                             ///< Allocated video device for this playback.

    mpe_Bool initialBlockingState;                          ///< Indicates whether the initial presentation should be
                                                            ///< blocked by displaying a black video area.

    mpe_Bool muted;                                         ///< Initial state of the audio decoder.

    float requestedGain;                                    ///< Initial decibel gain for this playback session.

    float requestedRate;                                    ///< Initial playback rate. 1.0 indicates normal playback, any
                                                            ///< other value means trick play mode.

    int64_t initialMediaTimeNS;                             ///< Requested start media time. If -1 is supplied, no
                                                            ///< TimeSeekRange.dlna.org header should be included in the
                                                            ///< HTTP request(s).

    uint32_t cciDescSize;                                   ///< Number of CCI descriptors extracted by the stack during the SI
                                                            ///> HN PAT/PMT and audio/video PID discovery process.

    mpe_HnPlaybackTransportCCI* cciDescData;                ///< Pointer to an allocated structure that conveys per-PID copy
                                                            ///< control information extracted from the PMT of the incoming
                                                            ///< stream. Allocated memory equals
                                                            ///< cciDescSize * sizeof(mpe_HnPlaybackTransportCCI).
}
mpe_HnPlaybackParamsMediaPlayerHttp;


/*****************************************************************************/
/***                                                                       ***/
/***                     PLAYER/SERVER SHARED FUNCTIONS                    ***/
/***                                                                       ***/
/*****************************************************************************/

/** @name Functions used by both player and server
 */
///@{
/**
 * This function performs platform-specific initialization for the home
 * networking module.
 *
 * Upon successful initialization, the underlying HN server platform should
 * store the value of the initialized DTCP/IP AKE server listening port in the
 * "MPE.HN.SERVER.DTCPIP.AKE.PORT" MPE environment variable.
 *
 * @return  ::MPE_HN_ERR_NOERR         If the subsystem initialization is successful.<br>
 *          ::MPE_HN_ERR_OS_FAILURE    Otherwise.
 **/
mpe_Error mpeos_hnInit(void);

/**
 * The mpeos_hnStreamClose() function closes the underlying streaming session
 * and releases the associated resources. Upon successful exit, the event
 * ::MPE_HN_EVT_SESSION_CLOSED will be sent to the associated event queue.
 *
 * @param session    An active streaming session handle, as returned by the
 *                   mpeos_hnStreamOpen() call.
 *
 * <b>Events:</b>
 * <ul> <li>::MPE_HN_EVT_SESSION_CLOSED Indicating that the streaming session was closed successfully.</li>
 * </ul>
 *
 * @return  ::MPE_HN_ERR_NOERR            If successful.<br>
 *          ::MPE_HN_ERR_INVALID_PARAM    If the parameter is invalid.<br>
 *          ::MPE_HN_ERR_OS_FAILURE       For OS-specific failures.<br>
 **/
mpe_Error mpeos_hnStreamClose(mpe_HnStreamSession session);

/**
 * The mpeos_hnStreamOpen() function should allocate the resources necessary to
 * start the asynchronous streaming operation. An error code is synchronously
 * returned to the caller to indicate a preliminary state of resource
 * allocation.
 *
 * Note the the supplied event queue can receive both streaming and playback
 * related events:
 * - ::MPE_HN_EVT_END_OF_CONTENT
 * - ::MPE_HN_EVT_BEGINNING_OF_CONTENT
 * - ::MPE_HN_EVT_SESSION_CLOSED
 * - ::MPE_HN_EVT_SESSION_OPEN
 * - ::MPE_HN_EVT_PLAYBACK_START
 * - ::MPE_HN_EVT_PLAYBACK_STOPPED
 * - ::MPE_HN_EVT_SESSION_NO_LONGER_AUTHORIZED
 * - ::MPE_HN_EVT_FAILURE
 *
 * @param openParams          Allocation and populated streaming params:<br>
 *                            mpe_HnStreamParamsMediaServerHttp for SERVER;<br>
 *                            mpe_HnStreamParamsMediaPlayerHttp for PLAYER.
 * @param queueId             Queue for posting of streaming events.
 * @param act                 Context value for the event dispatcher.
 * @param streamingSession    Opaque handle to the streaming session, supplied
 *                            by the underlying HN platform implementation.
 *
 * <b>Events:</b>
 * <ul>
 * <li>::MPE_HN_EVT_SESSION_OPEN For a successfully opened streaming session.</li>
 * <li>::MPE_HN_EVT_SESSION_NO_LONGER_AUTHORIZED If the associated DTCP/IP session is no longer authorized.</li>
 * </ul>
 *
 * @return ::MPE_HN_ERR_NOERR                If successful.<br>
 *         ::MPE_HN_ERR_INVALID_PARAM        If a parameter is invalid.<br>
 *         ::MPE_HN_ERR_OS_FAILURE           OS-specific failures.<br>
 *         ::MPE_HN_ERR_CONTENT              If the failure has occurred while acquiring the content. This includes DTCP/IP-related problems. <br>
 **/
mpe_Error mpeos_hnStreamOpen(mpe_HnStreamParams * openParams,
        mpe_EventQueue queueId, void * act,
        mpe_HnStreamSession * streamingSession);

/**
 * This function creates and starts a new HN playback for a given HN streaming
 * session. A new playback handle is returned if the call is successful.
 *
 * For HN players, the returned handle can be used to control the playback
 * parameters such as PID and CCI settings, blocking state, mute state and
 * volume gain.
 *
 * If presentation cannot be performed due to missing A/V components, and/or
 * the videoDevice is not specified, the platform must make best-effort
 * presentation and honor section filters against the associated
 * streamingSession. If video presentation cannot be performed and the
 * videoDevice is specified, black must be rendered into the video plane. If
 * the platform can determine components when none are specified (e.g. via
 * AVStreamParameters), it may use those components to perform presentation
 * until a call to mpeos_hnPlaybackChangePIDs() is made which specifies
 * component PIDs.
 *
 * Any client playback changes to media time or rate will cause the stack to
 * stop the current playback session by calling mpeos_hnPlaybackStop() followed
 * by another call to mpeos_hnPlaybackStart() containing the new parameters.
 *
 * For HN player playback of remote content this update sequence will also be
 * executed. First, mpeos_hnPlaybackStart() call will contain null
 * avStreamParameters and is used by the stack to initiate SI/PID discovery
 * process. Second call will contain valid avStreamParameters and will restart
 * the playback session from the beginning.
 *
 * Section filters set on the associated streamingSession must be honored for
 * play rates between -2.0 and +2.0 (inclusive) when the HN player playback
 * session is active.
 *
 * @param streamingSession    An active streaming session handle describing the
 *                            streaming values of this playback session.
 * @param playbackParams      The stream parameter changes for this playback:<br>
 *                            mpe_HnPlaybackParamsMediaServerHttp for SERVER;<br>
 *                            mpe_HnPlaybackParamsMediaPlayerHttp for PLAYER.
 * @param act                 The completion token for async events.
 * @param playbackSession     HN session playback handle, supplied by the
 *                            underlying HN platform implementation.
 *
 * The following playback related events can be sent to the associated
 * streaming session event queue. For details regarding the semantics specific
 * to server and player events, refer to the mpe_HnEvent structure documentation.
 *
 * <b>Events:</b>
 * <ul>
 * <li>::MPE_HN_EVT_END_OF_CONTENT</li>
 * <li>::MPE_HN_EVT_BEGINNING_OF_CONTENT</li>
 * <li>::MPE_HN_EVT_PLAYBACK_START</li>
 * <li>::MPE_HN_EVT_PLAYBACK_STOPPED</li>
 * <li>::MPE_HN_EVT_FAILURE</li>
 * <li>::MPE_HN_EVT_INACTIVTY_TIMEOUT</li>
 * </ul>
 *
 * @return ::MPE_HN_ERR_NOERR            If successful. <br>
 *         ::MPE_HN_ERR_INVALID_PARAM    If a parameter is invalid or there is an
 *                                        existing playback which has not been
 *                                        stopped.<br>
 *         ::MPE_HN_ERR_OS_FAILURE       OS-specific failures.<br>
 *         ::MPE_HN_ERR_CONTENT          If the failure has occurred while
 *                                        acquiring the content. This includes
 *                                        DTCP/IP-related problems.<br>
 **/
mpe_Error mpeos_hnPlaybackStart(mpe_HnStreamSession streamingSession,
        mpe_HnPlaybackParams * playbackParams, void * act,
        mpe_HnPlaybackSession * playbackSession);

/**
 * This function stops a given playback. This function frees any memory that
 * was used to store playbackSession data. Calling this methods allows another
 * playback to be started that is associated with this session.
 *
 * @param playbackSession    Handle to a playback session.
 * @param holdFrameMode the presentation mode to use once the playback has stopped
 *
 * @return ::MPE_HN_ERR_NOERR            If successful.<br>
 *         ::MPE_HN_ERR_INVALID_PARAM    If a parameter is invalid.<br>
 *         ::MPE_HN_ERR_OS_FAILURE       OS-specific failures.
 **/
mpe_Error mpeos_hnPlaybackStop(mpe_HnPlaybackSession playbackSession,
                               mpe_MediaHoldFrameMode holdFrameMode);

/**
 * Return the MAC address associated with the network interface whose display
 * name matches the supplied name. The list of valid networking interface names
 * is supplied by the underlying platform implementation itself. Refer to
 * mpeos_socketGetInterfaces() method and related mpe_SocketNetIfList structure
 * for more details.
 *
 * @param ifDisplayName    Find interface whose name matches this value.
 * @param macAddress       MAC address associated with network interface,
 *                         copied into this caller-allocated string array. The
 *                         string should be in the format "12:34:56:78:9A:BC".
 *
 * @return  ::MPE_HN_ERR_NOERR         If successful.<br>
 *          ::MPE_HN_ERR_OS_FAILURE    If problems are encountered.
 */
mpe_Error mpeos_hnGetMacAddress(char * ifDisplayName,
        char macAddress[MPE_HN_MAX_MAC_ADDRESS_STR_SIZE]);

/**
 * Return the type of the network interface as defined in
 * org.ocap.hn.NetworkInterface associated with the network interface whose
 * display name matches the supplied name.
 *
 * @param ifDisplayName    Find interface whose name matches this value.
 * @param type             Returned type of network interface. Valid set of
 *                         values is the set of constants defined in the
 *                         org.ocap.hn.NetworkInterface interface definition.
 *
 * @return ::MPE_HN_ERR_NOERR         If successful.<br>
 *         ::MPE_HN_ERR_OS_FAILURE    If problems are encountered.
 **/
mpe_Error mpeos_hnGetNetworkInterfaceType(char * ifDisplayName,
        int32_t * type);

/**
 * Issues ICMP echo requests packets to the target host and returns results.
 * This api will block until the pings succeeds,fails or test is cancelled. 
 *
 * @param   testid     id associated with this test. 
 * @param   host       name or address of host to ping. Must not be empty string.
 *                     If value is null or empty "Error_Other"
 *                     is returned in status buffer and additional detail is put in
 *                     the info buffer( ie "null host string").
 * @param   reps       number of requests to send.
 *                     Value must be between MPE_SOCKET_PING_MIN_COUNT and
 *                     MPE_SOCKET_PING_MAX_COUNT. If value is not valid "Error_Other"
 *                     is returned in status buffer and additional detail is put in
 *                     the info buffer( ie "reps out of range"). 
 * @param   interval   length of time in msec to wait between sending each request.
 *                     Value must be between MPE_SOCKET_PING_MIN_INTERVAL and
 *                     MPE_SOCKET_PING_MAX_INTERVAL. If value is not valid Error_other is
 *                     returned in status and additional detail may be put in
 *                     the info buffer.
 * @param   timeout    length of time in msec to wait for response to request.
 *                     Value must be between MPE_SOCKET_MIN_TIMEOUT and
 *                     MPE_SOCKET_MAX_TIMEOUT. If value is not valid "Error_Other" 
 *                     is returned in status buffer and additional detail is put in
 *                     the info buffer.
 * @param   blocksize  size of each packets data block in bytes. Value must be between
 *                     MPE_SOCKET_MIN_BLOCK_SIZE and
 *                     MPE_SOCKET_MAX_BLOCK_SIZE. If value is not valid
 *                     Error_other is returned in status and additional detail
 *                     may be put in the info buffer. 
 * @param   dscp       Diff Serv Point Code value in IP header. Value must be between
 *                     MPE_SOCKET_MIN_DSCP and MPE_SOCKET_MAX_DSCP.
 *                     If value is not valid "Error_Other"
 *                     is returned in status buffer and additional detail is put in
 *                     the info buffer.
 * @param   status     returned null terminated string copied into this
 *                     caller-allocated string array of length MPE_SOCKET_STATUS_SIZE
 *                     indicating overall success of test.
 *                     Valid values are "Success","Error_CannotResolveHostName".
 *                     "Error_Other" and "Error_Internal". 
 *                     "Success","Error_CannotResolveHostName" and "Error_Other"
 *                     must be supported.
 *                     String is truncated if greater than MPE_SOCKET_STATUS_SIZE.
 * @param   info       returned null terminated free formatted string of length
 *                     MPE_SOCKET_ADDITIONAL_INFO_SIZE copied into
 *                     this caller-allocated string array that can contain
 *                     additional information about the test.
 *                     String is truncated if greater than
 *                     MPE_SOCKET_ADDITIONAL_INFO_SIZE.  
 * @param   success    returned number of successful pings 
 * @param   fails      returned number of failed pings
 * @param   avg        returned average response time in msec of successful pings
 *                     or 0 if there were none. 
 * @param   min        returned minimum response time in msec of successful pings 
 *                     or 0 if there were none. 
 * @param   max        returned maximum response time in msec of successful pings 
 *                     or 0 if there were none. 
 *
 * @return ::MPE_HN_ERR_NOERR         If successful.<br>
 *         ::MPE_HN_ERR_OS_FAILURE    If problems are encountered executing the test.
 **/
mpe_Error mpeos_hnPing(int testid, char *host, int32_t reps, int32_t interval, int32_t timeout, int32_t blocksize, int32_t dscp, char *status, char *info, int32_t *success, int32_t *fails, int32_t *avg, int32_t *min, int32_t *max);

/**
 * Issues an IP layer traceroute and returns results.
 * Traceroute issues a sequence of ICMP echo request packets to a target host
 * and determines the intermediate routers transversed.
 * This api blocks until the traceroute succeeds, fails or test is cancelled. 
 *
 * @param   testid     id associated with this test. 
 * @param   host       name or address of host to probe. Must not be empty string.
 *                     If value is null or empty "Error_Other"
 *                     is returned in status buffer and additional detail is put in
 *                     the info buffer( ie "null host string").
 * @param   hops       max number of hops(ie maximum time-to_live). Value must be between
 *                     MPE_SOCKET_TRACEROUTE_MIN_HOPS and MPE_SOCKET_TRACEROUTE_MAX_HOPS.
 *                     If value is not valid "Error_Other"
 *                     is returned in status buffer and additional detail is put in
 *                     the info buffer.
 * @param   timeout    length of time in msec to wait for response to probe.
 *                     Value must be between MPE_SOCKET_MIN_TIMEOUT and
 *                     MPE_SOCKET_MAX_TIMEOUT.
 *                     If value is not valid "Error_Other" 
 *                     is returned in status buffer and additional detail is put in
 *                     the info buffer.
 * @param   blocksize  size of each packets data block in bytes. Value must be between
 *                     MPE_SOCKET_MIN_BLOCK_SIZE and
 *                     MPE_SOCKET_MAX_BLOCK_SIZE. If value is not valid
 *                     Error_other is returned in status and additional detail
 *                     may be put in the info buffer. 
 * @param   dscp       Diff Serv Point Code value in IP header. Value must be between
 *                     MPE_SOCKET_MIN_DSCP and MPE_SOCKET_MAX_DSCP.
 *                     If value is not valid "Error_Other"
 *                     is returned in status buffer and additional detail is put in
 *                     the info buffer.
 * @param   status     returned null terminated string copied into this
 *                     caller-allocated string array of length MPE_SOCKET_STATUS_SIZE
 *                     indicating overall success of test.
 *                     Valid values are "Success","Error_CannotResolveHostName",
 *                     "Error_MaxHopCountExceeded","Error_Internal" and "Error_Other".
 *                     "Success","Error_CannotResolveHostName","Error_MaxHopCountExceeded"
 *                     and "Error_Other" must be supported.
 *                     String is truncated if greater than MPE_SOCKET_STATUS_SIZE.
 * @param   info       returned null terminated free formatted string of length
 *                     MPE_SOCKET_ADDITIONAL_INFO_SIZE copied into
 *                     this caller-allocated string array that can contain
 *                     additional information about the test.
 *                     String is truncated if greater than
 *                     MPE_SOCKET_ADDITIONAL_INFO_SIZE.  
 * @param   avgresp    returned average response time of probes in msec 
 * @param   hophosts   null terminated string array copied into this caller-allocated
 *                     string array of length MPE_SOCKET_MAX_TRACEROUTE_HOSTS
 *                     Comma-separated list of host IP addresses
 *                     along the discovered route. If a host could not be contacted,
 *                     the corresponding entry in the list is empty, i.e.
 *                     there will be two consecutive
 *                     commas in the list, as in host1,,host3.
 *                     String is truncated if greater than
 *                     MPE_SOCKET_MAX_TRACEROUTE_HOSTS.  
 *
 * @return ::MPE_HN_ERR_NOERR         If successful.<br>
 *         ::MPE_HN_ERR_OS_FAILURE    If problems are encountered.
 **/
mpe_Error mpeos_hnTraceroute(int32_t testid, char *host, int32_t reps, int32_t timeout, int32_t blocksize, int32_t dscp, char *status, char *info, int32_t *avgresp, char *hophosts);

/**
 * Issues an IP layer DNS lookup and returns results.
 * Queries a supplied DNS server for domain name and IP address 
 * mappings for a target host. 
 *
 * @param   testid         id associated with this test. 
 * @param   host           name of host to lookup. Must not be empty string.
 *                         If name is not fully qualified current domain is used for
 *                         lookup.
 *                         If value is not valid(empty string). "Error_Other"
 *                         is returned in status buffer and additional detail is put in
 *                         the info buffer( ie "null host string").
 * @param   server         name or address of server to use. An empty string denotes 
 *                         using the default server. If name or address is not resolvable
 *                         "Error_DNSServerNotAvailable" is returned in the status buffer. 
 * @param   timeout        length of time in msec to wait for response to probe.
 *                         Value must be between MPE_SOCKET_MIN_TIMEOUT and
 *                         MPE_SOCKET_MAX_TIMEOUT.
 *                         If value is not valid "Error_Other" 
 *                         is returned in status buffer and additional detail is put in
 *                         the info buffer.
 * @param   status         returned null terminated string copied into this
 *                         caller-allocated string array of length MPE_SOCKET_STATUS_SIZE
 *                         indicating overall success of test.
 *                         Valid values are "Success","Error_DNSServerNotResolved",
 *                         "Error_DNSServerNotAvailable","Error_Internal","Error_Other"
 *                         "ErrorHostNameNot-Resolved" and "Error_Timeout".
 *                         "Success","Error_DNSServerNotResolved" and "Error_Other"
 *                         must be supported.
 *                         String is truncated if greater than MPE_SOCKET_STATUS_SIZE.
 * @param   info           returned null terminated free formatted string of length
 *                         MPE_SOCKET_ADDITIONAL_INFO_SIZE copied into
 *                         this caller-allocated string array that can contain
 *                         additional information about the test.
 *                         String is truncated if greater than
 *                         MPE_SOCKET_ADDITIONAL_INFO_SIZE.
 * @param   resultAnswer   returned null terminated string of DNS answer type 
 *                         copied into this caller-allocated string array of length
 *                         MPE_SOCKET_MAX_NSLOOKUP_ANSWER_RESULT_SIZE.
 *                         Valid values are "None", "Authoritative" or NonAuthoritative". 
 * @param   resultName     returned null terminated string of DNS fully qualified name of host 
 *                         copied into this caller-allocated string array of length
 *                         MPE_SOCKET_MAX_NSLOOKUP_NAME_RESULT_SIZE.
 *                         String is truncated if greater than MPE_SOCKET_MAX_NSLOOKUP_NAME_RESULT_SIZE.
 * @param   resultIPS      returned null terminated string of DNS IP addresses resolved for host 
 *                         copied into this caller-allocated string array of length
 *                         MPE_SOCKET_MAX_NSLOOKUP_IPS_RESULT_SIZE.
 *                         This is a comma-separated list if IP addresses returned by lookup or empty
 *                         string if none found. 
 *                         String is truncated if greater than MPE_SOCKET_MAX_NSLOOKUP_IPS_RESULT_SIZE.          
 * @param   resultServer   returned null terminated string of DNS Server IP address used  
 *                         copied into this caller-allocated string array of length
 *                         MPE_SOCKET_MAX_NSLOOKUP_SERVER_RESULT_SIZE.
 *                         String is truncated if greater than MPE_SOCKET_MAX_NSLOOKUP_IPS_RESULT_SIZE.
 * @param   resultTime     Response time of lookup in msec 
 *
 * @return ::MPE_HN_ERR_NOERR         If successful.<br>
 *         ::MPE_HN_ERR_OS_FAILURE    If problems are encountered.
 **/
mpe_Error mpeos_hnNSLookup(int32_t testid, char *host, char *server, int32_t timeout, char *status, char *info, char *resultAnswer, char *resultName, char *resultIPS, char *resultServer, int *resultTime);

/**
 * Cancels a Ping/Traceroute or NSLookup Test
 *
 * @param   testid                       id of test to cancel.
 * @return ::MPE_HN_ERR_NOERR            If successful.<br>
 *         ::MPE_HN_ERR_OS_FAILURE       OS-specific failures.
 **/
mpe_Error mpeos_hnCancelTest(int32_t testid);

///@}


/*****************************************************************************/
/***                                                                       ***/
/***                            SERVER FUNCTIONS                           ***/
/***                                                                       ***/
/*****************************************************************************/
/** @name Functions used by server
 */
///@{
/**
 * mpeos_hnServerUpdateEndPosition() adjusts the end byte position of the
 * currently-presenting stream.
 *
 * The specified byte position will always be passed in network byte domain.
 * For playbacks that are part of DTCP-enabled server streaming sessions, this
 * means that requested position already accounts for PCP-encapsulation.
 *
 * @param playbackSession    Active playback session to be updated.
 * @param endBytePosition    The new end byte position.  A value representing a
 *                           byte position that has already been streamed
 *                           should behave the same as if the request was fully
 *                           satisfied, including MPE_HN_EVT_END_OF_CONTENT
 *                           being sent to the event queue. A value of -1
 *                           should result in streaming of all available
 *                           content.
 *
 * @return MPE_HN_ERR_NOERR            If successful.
 *         MPE_HN_ERR_INVALID_PARAM    If one of the parameters is invalid.
 *         MPE_HN_ERR_OS_FAILURE       OS-specific failures.
 **/
mpe_Error mpeos_hnServerUpdateEndPosition(mpe_HnPlaybackSession
        playbackSession, int64_t endBytePosition);

/**
 * mpeos_hnServerGetNetworkContentItemSize() should return the total number of
 * bytes of content which would be streamed across the network associated with
 * the supplied content item using the DLNA profile and mime type identified by
 * the supplied strings.
 *
 * The profileIDStr parameter can be prefixed with "DTCP_" string, indicating
 * that the stack is requesting PCP-encapsulated item size.
 *
 * @param contentLocation       Indicates content location type such as
 *                              recording, TSB, etc.
 * @param contentDescription    Structure describing content which varies
 *                              depending on content location type provided.
 * @param profileIDStr          DLNA media format to be used in network
 *                              transfer of this content. The actual profile ID
 *                              string can be prefixed with "DTCP_" string to
 *                              indicate that the stack is requesting PCP-
 *                              encapsulated content item size.
 * @param mimeTypeStr           Mime type to be used in network transfer of
 *                              this content. The stack will never use
 *                              "application/x-dtcp1" content format here; in
 *                              case of DTCP/IP transmissions, the actual
 *                              "CONTENTFORMAT" value will be conveyed here.
 * @param transformation        The transformation to be applied. If the native
 *                              version of the content is being streamed, this
 *                              will be NULL.
 * @param fileSizeBytes         Returns total number of bytes that will be
 *                              streamed across network for this content using
 *                              the supplied DLNA profile and mime type
 *                              settings. If size cannot be determined (e.g.
 *                              transformed content) -1 is returned.
 *
 * @return MPE_HN_ERR_NOERR            If successful.
 *         MPE_HN_ERR_INVALID_PARAM    If one of the parameters is invalid.
 *         MPE_HN_ERR_OS_FAILURE       OS-specific failures.
 **/
mpe_Error mpeos_hnServerGetNetworkContentItemSize(
        mpe_HnStreamContentLocation contentLocation, void * contentDescription,
        char * profileIDStr, char * mimeTypeStr, mpe_hnContentTransformation * transformation,
        int64_t * fileSizeBytes);

/**
 * mpeos_hnServerGetNetworkBytePosition() should translate the requested
 * local byte position into a network byte position for the supplied content
 * item using the DLNA profile and mime type identified by the supplied
 * strings.
 *
 * For non-DTCP profileIDs, this should be a no-op and the returned network
 * byte position should be the same as the requested local byte position.
 *
 * @param contentLocation       Indicates content location type such as
 *                              recording, TSB, etc.
 * @param contentDescription    Structure describing content which varies
 *                              depending on content location type provided.
 * @param profileIDStr          DLNA media format to be used in network
 *                              transfer of this content. The actual profile ID
 *                              string can be prefixed with "DTCP_" string to
 *                              indicate that the stack is performing byte
 *                              position translation from cleartext domain to
 *                              encrypted domain.
 * @param mimeTypeStr           Mime type to be used in network transfer of
 *                              this content. The stack will never use
 *                              "application/x-dtcp1" content format here; in
 *                              case of DTCP/IP transmissions, the actual
 *                              "CONTENTFORMAT" value will be conveyed here.
 * @param transformation        The transformation to be applied. If the native
 *                              version of the content is being streamed, this
 *                              will be NULL.
 * @param localBytePosition     Local byte position to be translated.
 * @param networkBytePosition   Returns network byte position of content
 *                              streamed across the network using supplied DLNA
 *                              profile and mime type settings. The returned
 *                              network byte position must start at Decoder
 *                              Friendly Alignment Position as defined by DLNA
 *                              DLNA Guidelines Volume 2.
 *                              If byte position cannot be determined (e.g.
 *                              transformed content) -1 is returned.
 *
 * @return MPE_HN_ERR_NOERR            If successful.
 *         MPE_HN_ERR_INVALID_PARAM    If one of the parameters is invalid.
 *         MPE_HN_ERR_OS_FAILURE       OS-specific failures.
 **/
mpe_Error mpeos_hnServerGetNetworkBytePosition(
        mpe_HnStreamContentLocation contentLocation, void * contentDescription,
        char * profileIDStr, char * mimeTypeStr, mpe_hnContentTransformation * transformation,
        int64_t localBytePosition, int64_t * networkBytePosition);

/**
 * mpeos_hnServerGetNetworkBytePositionForMediaTimeNS() should translate the
 * requested media time into a network byte position for the supplied content
 * item using the DLNA profile and mime type identified by the supplied
 * strings.
 *
 * @param contentLocation       Indicates content location type such as
 *                              recording, TSB, etc.
 * @param contentDescription    Structure describing content which varies
 *                              depending on content location type provided.
 * @param profileIDStr          DLNA media format to be used in network
 *                              transfer of this content. The actual profile ID
 *                              string can be prefixed with "DTCP_" string to
 *                              indicate that the stack is performing media
 *                              time lookup on PCP-encapsulated content item.
 * @param mimeTypeStr           Mime type to be used in network transfer of
 *                              this content. The stack will never use
 *                              "application/x-dtcp1" content format here; in
 *                              case of DTCP/IP transmissions, the actual
 *                              "CONTENTFORMAT" value will be conveyed here.
 * @param transformation        The transformation to be applied. If the native
 *                              version of the content is being streamed, this
 *                              will be NULL.
 * @param mediaTimeNS           Media time in nanoseconds to query for byte
 *                              position.
 * @param bytePosition          Returns byte position of content streamed
 *                              across the network using supplied DLNA profile
 *                              and mime type settings for the specified media
 *                              time. The returned byte position must start at
 *                              Decoder Friendly Alignment Position as defined
 *                              by DLNA Guidelines Volume 2.
 *                              If byte position cannot be determined (e.g.
 *                              transformed content) -1 is returned.
 *
 * @return MPE_HN_ERR_NOERR            If successful.
 *         MPE_HN_ERR_INVALID_PARAM    If one of the parameters is invalid.
 *         MPE_HN_ERR_OS_FAILURE       OS-specific failures.
 **/
mpe_Error mpeos_hnServerGetNetworkBytePositionForMediaTimeNS(
        mpe_HnStreamContentLocation contentLocation, void * contentDescription,
        char * profileIDStr, char * mimeTypeStr, mpe_hnContentTransformation * transformation,
        int64_t mediaTimeNS, int64_t * bytePosition);

/**
 * Retrieves number/count of support content transformation from the platform.
 * See the definition of mpe_hnContentTransformation for more information.
 *
 * @param contentTransformationCnt  Returns number/count of supported transformations. If 0,
 *                                  the platform doesn't provide any transformations.
 *
 * @return MPE_HN_ERR_NOERR            If successful.
 */
mpe_Error mpeos_hnServerGetContentTransformationCnt(uint32_t * contentTransformationCnt);

/**
 * Retrieves the supported content transformations from the platform. See the definition of
 * mpe_hnContentTransformation for more information.
 *
 * @param contentTransformations  Address of an array sufficient to hold the number of
 * content transformations structures returned from mpeos_hnServerGetContentTransformationCnt.
 * Note: Each mpe_hnContentTransformation must have a unique ID.
 *
 * @return MPE_HN_ERR_NOERR            If successful.
 */
mpe_Error mpeos_hnServerGetContentTransformations(
        mpe_hnContentTransformation contentTransformations[]);

/**
 * Retrieves number/count of supported DLNA profile ID strings that are
 * available for the supplied content item.
 *
 * For a content item reference that has no associated file system resources at
 * the time of the method call such as a time-shift buffer or a scheduled
 * recording, the content description may be NULL. In this case, the platform
 * should return all possible supported DLNA media profiles available for
 * transfer of the supplied content type.
 *
 * The underlying HN server implementation should never include "DTCP_"
 * prefixed profiles in this enumeration.
 *
 * @param contentLocation       Indicates content location type such as
 *                              recording, TSB, etc.
 * @param contentDescription    Structure describing content which varies
 *                              depending on content location type provided.
 * @param profileIDCnt          Returns number/count of supported DLNA profile
 *                              IDs for this content item.
 *
 * @return MPE_HN_ERR_NOERR            If successful.
 * @return MPE_HN_ERR_INVALID_PARAM    If content type is not supported.
 **/
mpe_Error mpeos_hnServerGetDLNAProfileIDsCnt(
        mpe_HnStreamContentLocation contentLocation, void * contentDescription,
        uint32_t * profileIDCnt);

/**
 * Returns DLNA profile ID string at requested index from array of possible
 * DLNA profile IDs which are applicable to supplied content item. This method
 * will return profileIDStr, assuming caller has allocated memory whose size is
 * MPE_HN_MAX_DLNA_PROFILE_ID_STR_SIZE.
 *
 * The index number also indicates the platform preferred DLNA profile ID. For
 * example, index 0 is the most preferred playback format for streaming of this
 * content item, index 1 is the second most preferred format, etc.
 *
 * The underlying HN server implementation should never include "DTCP_"
 * prefixed profiles.
 *
 * @param contentLocation       Indicates content location type such as
 *                              recording, TSB, etc.
 * @param contentDescription    Structure describing content which varies
 *                              depending on content location type provided.
 * @param idx                   Retrieve this index in array of supported DLNA
 *                              profile IDs (indices start at 0, through
 *                              count-1), based on count returned via
 *                              mpeos_hnServerGetDLNAProfileIDsSizeCnt().
 * @param profileIDStr          Returns requested DLNA profiles ID string from
 *                              specified index in caller allocated memory of
 *                              MPE_HN_MAX_DLNA_PROFILE_ID_STR_SIZE.
 *
 * @return MPE_HN_ERR_NOERR            If successful.
 * @return MPE_HN_ERR_INVALID_PARAM    If content type is not supported or
 *                                     index is out of range.
 **/
mpe_Error mpeos_hnServerGetDLNAProfileIDStr(
        mpe_HnStreamContentLocation contentLocation, void * contentDescription,
        uint32_t idx, char profileIDStr[MPE_HN_MAX_DLNA_PROFILE_ID_STR_SIZE]);

/**
 * Retrieves number/count of supported mime type strings that are available for
 * the supplied content item for a given DLNA profile ID.
 *
 * For a content item reference that has no associated file system resources at
 * the time of the method call such as a time-shift buffer or a scheduled
 * recording, the content description may be NULL. In this case, the platform
 * should return all possible supported mime types available for transfer of
 * the supplied content type.
 *
 * The underlying HN server implementation should never include
 * "application/x-dtcp1" mime type in this enumeration.
 *
 * @param contentLocation       Indicates content location type such as
 *                              recording, TSB, etc.
 * @param contentDescription    Structure describing content which varies
 *                              depending on content location type provided.
 * @param profileIdStr          DLNA profile ID for which to return the number
 *                              of supported mime types for the given content
 *                              item. The stack can pass "DTCP_"-prefixed
 *                              profile ID string to indicate that the content
 *                              item will be transmitted using PCP header
 *                              encapsulation.
 * @param mimeTypeCnt           Returns number/count of supported mime types
 *                              for this content item.
 *
 * @return MPE_HN_ERR_NOERR            If successful.
 * @return MPE_HN_ERR_INVALID_PARAM    If content/profileId is not supported.
 **/
mpe_Error mpeos_hnServerGetMimeTypesCnt(
        mpe_HnStreamContentLocation contentLocation, void * contentDescription,
        char * profileIdStr, uint32_t * mimeTypeCnt);

/**
 * Returns mime type string for the supplied content item using the specified
 * DLNA profile ID transfer. This method will return mime type string, assuming
 * caller has allocated memory whose size is MPE_HN_MAX_MIME_TYPE_STR_SIZE.
 *
 * The index number also indicates the platform preferred mime type when using
 * the supplied DLNA profile ID. For example, index 0 is the most preferred
 * playback format for streaming of this content item, index 1 is the second
 * most preferred format, etc.
 *
 * The underlying HN server implementation should never include
 * "application/x-dtcp1" mime type in this enumeration.
 *
 * @param contentLocation       Indicates content location type such as
 *                              recording, TSB, etc.
 * @param contentDescription    Structure describing content which varies
 *                              depending on content location type provided.
 * @param profileIdStr          Retrieve mime type for content item using this
 *                              DLNA media profile. The stack can pass "DTCP_"-
 *                              prefixed profile ID string to indicate that the
 *                              content item will be transmitted using PCP
 *                              header encapsulation.
 * @param idx                   Retrieve mime type for content item using the
 *                              specified profile ID at this index of available
 *                              supported mime types. Available range is (0,
 *                              through count-1), based on count returned via
 *                              mpeos_hnServerGetMimeTypeCnt().
 * @param mimeTypeStr           Returns mime type string using caller allocated
 *                              memory of MPE_HN_MAX_MIME_TYPE_STR_SIZE.
 *
 * @return MPE_HN_ERR_NOERR            If successful.
 * @return MPE_HN_ERR_INVALID_PARAM    If content/profileId/index combination
 *                                     is not supported.
 **/
mpe_Error mpeos_hnServerGetMimeTypeStr(
        mpe_HnStreamContentLocation contentLocation, void * contentDescription,
        char * profileIdStr, uint32_t idx,
        char mimeTypeStr[MPE_HN_MAX_MIME_TYPE_STR_SIZE]);

/**
 * Retrieves number/count of supported playspeed strings that are available for
 * the supplied content item.
 *
 * @param contentLocation       Indicates content location type such as
 *                              recording, TSB, etc.
 * @param contentDescription    Structure describing content which varies
 *                              depending on content location type provided.
 * @param profileIDStr          Retrieve supported playspeeds count for content
 *                              item using this DLNA media profile. The stack
 *                              can pass "DTCP_"-prefixed profile ID string to
 *                              indicate that the content item will be
 *                              transmitted using PCP header encapsulation.
 * @param mimeTypeStr           Retrieve supported playspeeds count for content
 *                              item using this mime type. The stack will never
 *                              pass "application/x-dtcp1" mime type here.
 * @param transformation        The transformation to be applied. If the native
 *                              version of the content is being streamed, this
 *                              will be NULL.
 * @param playspeedCnt          Returns number/count of supported playspeeds.
 *
 * @return MPE_HN_ERR_NOERR            If successful.
 * @return MPE_HN_ERR_INVALID_PARAM    If content/profileId/mimeType
 *                                     combination is not supported.
 **/
mpe_Error mpeos_hnServerGetPlayspeedsCnt(
        mpe_HnStreamContentLocation contentLocation, void * contentDescription,
        char * profileIDStr, char * mimeTypeStr, mpe_hnContentTransformation * transformation,
        uint32_t * playspeedCnt);

/**
 * Returns playspeed strings such as "-2", "-1/2", "2", etc. which are
 * supported for the supplied content item using the specified DLNA profile ID
 * transfer and mime type combination. Refer to DLNA Guidelines Volume 1:
 * Architectures and Protocols, ProtocolInfo Guidelines.
 *
 * This method will return playspeed string, assuming caller has allocated
 * memory whose size is MPE_HN_MAX_PLAYSPEED_STR_SIZE.
 *
 * @param contentLocation       Indicates content location type such as
 *                              recording, TSB, etc.
 * @param contentDescription    Structure describing content which varies
 *                              depending on content location type provided.
 * @param profileIDStr          Retrieve supported playspeed for content item
 *                              using this DLNA media profile. The stack can
 *                              pass "DTCP_"-prefixed profile ID string to
 *                              indicate that the content item will be
 *                              transmitted using PCP header encapsulation.
 * @param mimeTypeStr           Retrieve supported playspeed for content item
 *                              using this mime type. The stack will never pass
 *                              "application/x-dtcp1" mime type here.
 * @param transformation        The transformation to be applied. If the native
 *                              version of the content is being streamed, this
 *                              will be NULL.
 * @param idx                   Retrieve this index in array of supported
 *                              playspeeds (indices start at 0, through
 *                              count-1), based on count returned via
 *                              mpeos_hnServerGetPlayspeedsCnt().
 * @param playspeedStr          Returns playspeed string at specified index
 *                              using caller allocated memory of
 *                              MPE_HN_MAX_PLAYSPEED_STR_SIZE.
 *
 * @return MPE_HN_ERR_NOERR            If successful.
 * @return MPE_HN_ERR_INVALID_PARAM    If content/profileId/mimeType/idx
 *                                     combination is not supported.
 **/
mpe_Error mpeos_hnServerGetPlayspeedStr(
        mpe_HnStreamContentLocation contentLocation, void * contentDescription,
        char * profileIDStr, char * mimeTypeStr, mpe_hnContentTransformation * transformation,
        uint32_t idx, char playspeedStr[MPE_HN_MAX_PLAYSPEED_STR_SIZE]);

/**
 * Returns value which indicates the frame types that can be expected in a
 * group of pictures for requested content using supplied profile ID and mime
 * type combination at specified playspeed.  If server returns a value of
 * "I", this indicates that the server can only support "I" Frames. If server
 * returns a value of "IP", this indicates that a server can support both
 * "I" and "IP" frames.  If server returns a value of "all", this indicates
 * server can support "I", "IP" and "all".
 *
 * Refer to <a href="http://www.cablelabs.com/specifications/">OC-SP-HNP2.0 specification</a>,
 * section 5.6.1.6 FrameTypesInTrickMode for more relevant details.
 *
 * @param contentLocation       Indicates content location type such as
 *                              recording, TSB, etc.
 * @param contentDescription    Structure describing content which varies
 *                              depending on content location type provided.
 * @param profileIDStr          Retrieve supported frame types for content item
 *                              using this DLNA media profile. The stack can
 *                              pass "DTCP_"-prefixed profile ID string to
 *                              indicate that the content item will be
 *                              transmitted using PCP header encapsulation.
 * @param mimeTypeStr           Retrieve supported frame types for content item
 *                              using this mime type. The stack will never pass
 *                              "application/x-dtcp1" mime type here.
 * @param transformation        The transformation to be applied. If the native
 *                              version of the content is being streamed, this
 *                              will be NULL.
 * @param playspeedRate         Retrieve supported frame types for content item
 *                              at this playspeed.
 * @param frameType             Returns types of frames which will be sent for
 *                              the specified content/profile/mime type/
 *                              playspeed combination.
 *
 * @return MPE_HN_ERR_NOERR            If successful.
 * @return MPE_HN_ERR_INVALID_PARAM    If content/profileId/mimeType/playspeed
 *                                     combination is not supported.
 **/
mpe_Error mpeos_hnServerGetFrameTypesInTrickMode(
        mpe_HnStreamContentLocation contentLocation, void * contentDescription,
        char * profileIDStr, char * mimeTypeStr, mpe_hnContentTransformation * transformation,
        float playspeedRate, mpe_HnHttpHeaderFrameTypesInTrickMode * frameType);

/**
 * Returns the frames per second setting which will be applied by this server
 * to the outgoing stream for requested content using supplied profile ID and
 * mime type combination at specified playspeed.
 *
 * Refer to <a href="http://www.cablelabs.com/specifications/">OC-SP-HNP2.0 specification</a>,
 * section 5.6.1.7 FrameRateInTrickMode for more relevant details.
 *
 * @param contentLocation       Indicates content location type such as
 *                              recording, TSB, etc.
 * @param contentDescription    Structure describing content which varies
 *                              depending on content location type provided.
 * @param profileIDStr          Retrieve supported frame rate for content item
 *                              using this DLNA media profile. The stack can
 *                              pass "DTCP_"-prefixed profile ID string to
 *                              indicate that the content item will be
 *                              transmitted using PCP header encapsulation.
 * @param mimeTypeStr           Retrieve supported frame rate for content item
 *                              using this mime type. The stack will never pass
 *                              "application/x-dtcp1" mime type here.
 * @param transformation        The transformation to be applied. If the native
 *                              version of the content is being streamed, this
 *                              will be NULL.
 * @param playspeedRate         Retrieve supported frame rate for content item
 *                              at this playspeed.
 * @param framesPerSec          Returns rate in frames per second which will be
 *                              applied to the outgoing content using the
 *                              using the supplied content/profile/mime type/
 *                              playspeed combination.
 *
 * @return MPE_HN_ERR_NOERR            If successful.
 * @return MPE_HN_ERR_INVALID_PARAM    If content/profileId/mimeType/playspeed
 *                                     combination is not supported.
 **/
mpe_Error mpeos_hnServerGetFrameRateInTrickMode(
        mpe_HnStreamContentLocation contentLocation, void * contentDescription,
        char * profileIDStr, char * mimeTypeStr, mpe_hnContentTransformation * transformation,
        float playspeedRate, int32_t * framesPerSec);
///@}

/**
 * Returns indication if connection stalling is supported for the outgoing stream
 * of the requested content using supplied profile ID and mime type combination.
 *
 * @param contentLocation               Indicates content location type such as
 *                                      recording, TSB, etc.
 * @param contentDescription            Structure describing content which varies
 *                                      depending on content location type provided.
 * @param profileIDStr                  Retrieve supported connection stalling for
 *                                      content item using this DLNA media profile.
 *                                      The stack can pass "DTCP_"-prefixed profile
 *                                      ID string to indicate that the content item
 *                                      will be transmitted using PCP header encapsulation.
 * @param mimeTypeStr                   Retrieve supported connection stalling for
 *                                      content item using this mime type. The stack
 *                                      will never pass "application/x-dtcp1" mime type here.
 * @param transformation                The transformation to be applied. If the native
 *                                      version of the content is being streamed, this
 *                                      will be NULL.
 * @param connectionSAtallingSupported  Returns true if connection stalling is
 *                                      supported for the outgoing content using the
 *                                      using the supplied content/profile/mime type
 *                                      combination.
 *
 * @return MPE_HN_ERR_NOERR            If successful.
 * @return MPE_HN_ERR_INVALID_PARAM    If content/profileId/mimeType
 *                                     combination is not supported.
 **/
mpe_Error mpeos_hnServerGetConnectionStallingFlag(
        mpe_HnStreamContentLocation contentLocation, void * contentDescription,
        char * profileIDStr, char * mimeTypeStr, mpe_hnContentTransformation * transformation,
        mpe_Bool * connectionStallingSupported);
///@}

/**
 * Returns indication if this requested content item's MPEG stream will be
 * paced by this server so that both the PCR time stamp in the TS header's
 * adaptation field and the PTS time stamp in the PES header are re-stamped
 * using supplied profile ID and mime type combination.
 *
 * Refer to <a href="http://www.cablelabs.com/specifications/">OC-SP-HNP2.0 specification</a>,
 * section 5.6.1.5 ServersidePacedStreaming for more relevant details.
 *
 * @param contentLocation               Indicates content location type such as
 *                                      recording, TSB, etc.
 * @param contentDescription            Structure describing content which varies
 *                                      depending on content location type provided.
 * @param profileIDStr                  Retrieve supported restamping for
 *                                      content item using this DLNA media profile.
 *                                      The stack can pass "DTCP_"-prefixed profile
 *                                      ID string to indicate that the content item
 *                                      will be transmitted using PCP header encapsulation.
 * @param mimeTypeStr                   Retrieve supported restamping for
 *                                      content item using this mime type. The stack
 *                                      will never pass "application/x-dtcp1" mime type here.
 * @param transformation                The transformation to be applied. If the native
 *                                      version of the content is being streamed, this
 *                                      will be NULL.
 * @param willRestamp                   Returns true if server will restamp the timestamps in
 *                                      outgoing content using the supplied content/profile/mime type
 *                                      combination, false otherwise.
 *
 * @return MPE_HN_ERR_NOERR            If successful.
 * @return MPE_HN_ERR_INVALID_PARAM    If content/profileId/mimeType
 *                                     combination is not supported.
 **/
mpe_Error mpeos_hnServerGetServerSidePacingRestampFlag(
        mpe_HnStreamContentLocation contentLocation, void * contentDescription,
        char * profileIDStr, char * mimeTypeStr, mpe_hnContentTransformation * transformation,
        mpe_Bool * willRestamp);
///@}

/**
 * Returns the segment info for the designated piece of content.
 *
 * Note that this method is only applicable for particular profiles and only
 * for content that supports the given profile as supplied via
 * mpeos_hnServerGetDLNAProfileIDStr() on the particular content.
 * e.g. content exposed in the following profiles must support this method:
 *
 * DASH_AVC_TS_ISO
 * DASH_AVC_MP4
 *
 * Note that segment representations conforming to profile DASH_AVC_TS_ISO and
 * must also be compliant with HLS media file/segment requirements.
 * Segment representations conforming to profile DASH_AVC_MP4
 * must also be compliant with IIS SmoothStreaming AVC/H.264 fragment requirements.
 *
 * @param contentLocation       Indicates content location type such as
 *                              recording, TSB, etc.
 * @param contentDescription    Structure describing content which varies
 *                              depending on content location type provided.
 * @param transformation        The transformation to be applied. If the native
 *                              version of the content is being streamed, this
 *                              will be NULL.
 * @param segmentInfo           Pointer to the segmentation info structure that will
 *                              return the segment information for the designated
 *                              content.
 *
 * @return MPE_HN_ERR_NOERR            If successful.
 * @return MPE_HN_ERR_INVALID_PARAM    If content location is invalid or
 *                                     the profile is not supported.
 **/
mpe_Error mpeos_hnServerGetSegmentationInfo(
        mpe_HnStreamContentLocation contentLocation, void * contentDescription,
        mpe_hnContentTransformation * transformation,
        mpe_hnSegmentedContentInfo *segmentInfo );
///@}

/*****************************************************************************/
/***                                                                       ***/
/***                            PLAYER FUNCTIONS                           ***/
/***                                                                       ***/
/*****************************************************************************/
/** @name Functions used by player
 */
///@{
/**
 * mpeos_hnPlayerStreamGetInfo() should return the current session parameters
 * for the target HN player streaming session.
 *
 * @param session         An active streaming session handle.
 * @param sessionParams   The allocated stream parameter structure to be
 *                        populated by the underlying HN player platform.
 *
 * @return MPE_HN_ERR_NOERR            If successful.
 *         MPE_HN_ERR_INVALID_PARAM    If any of the parameters is invalid.
 *         MPE_HN_ERR_OS_FAILURE       OS-specific failures.
 **/
mpe_Error mpeos_hnPlayerStreamGetInfo(mpe_HnStreamSession session,
        mpe_HnStreamParams * sessionParams);

/**
 * This function will change the audio/video stream presentation parameters
 * used for decoding and display on the underlying HN player implementation.
 *
 * For player playback of remote live content this method will be called
 * following the SI/PID discovery process initiated by the
 * mpeos_hnPlaybackStart() method call. The HN player platform implementation
 * is not expected to initiate any network activity as a result of this method
 * call - only an update to MPEG decoding process should be performed that will
 * result in valid audio/video component presentation.
 *
 * @param playbackSession    Active playback session to be updated.
 * @param pids               New audio and video PID types and values.
 *
 * @return MPE_HN_ERR_NOERR            If successful.
 *         MPE_HN_ERR_INVALID_PARAM    If any of the parameters is invalid.
 *         MPE_HN_ERR_OS_FAILURE       OS-specific failures.
 **/
mpe_Error mpeos_hnPlayerPlaybackChangePIDs(
        mpe_HnPlaybackSession playbackSession,
        mpe_HnHttpHeaderAVStreamParameters * pids);

/**
 * This function updates the copy control information for an active HN player
 * playback session.
 *
 * @param playbackSession    Active playback session to be updated.
 * @param cciDescSize        Number of mpe_HnPlaybackTransportCCI elements
 *                           in the structure that follows.
 * @param cciDescData        Updated CCI descriptor information.
 *
 * @return MPE_HN_ERR_NOERR            If successful.
 *         MPE_HN_ERR_INVALID_PARAM    If a parameter is invalid.
 *         MPE_HN_ERR_OS_FAILURE       OS-specific failures.
 **/
mpe_Error mpeos_hnPlayerPlaybackUpdateCCI(
        mpe_HnPlaybackSession playbackSession,
        uint32_t cciDescSize, mpe_HnPlaybackTransportCCI * cciDescData);

/**
 * This function returns the current playback media time. This time represents
 * how long the playback has been ongoing.
 *
 * @param playbackSession    Active playback session handle.
 * @param mediaTimeNS        Returns media time in nanoseconds.
 *
 * @return MPE_HN_ERR_NOERR            If successful.
 *         MPE_HN_ERR_INVALID_PARAM    If any of the parameters is invalid.
 *         MPE_HN_ERR_OS_FAILURE       OS-specific failures.
 **/
mpe_Error mpeos_hnPlayerPlaybackGetTime(mpe_HnPlaybackSession playbackSession,
        int64_t * mediaTimeNS);

/**
 * This function returns the current playback rate associated with given
 * playback.
 *
 * @param playbackSession    Active playback session handle.
 * @param mode               Returns current playback rate.
 *
 * @return MPE_HN_ERR_NOERR            If successful.
 *         MPE_HN_ERR_INVALID_PARAM    If any of the parameters is invalid.
 *         MPE_HN_ERR_OS_FAILURE       OS-specific failures.
 **/
mpe_Error mpeos_hnPlayerPlaybackGetRate(mpe_HnPlaybackSession playbackSession,
        float * mode);

/**
 * Block or unblock the presentation of the desired HN player playback session.
 * Blocking a playback session is accomplished by muting audio and displaying a
 * black video area. The playback session continues to process the stream as
 * expected, however, the audio is not emitted and the video is not displayed.
 * This method controls the blocking state of the decode session by either
 * blocking or unblocking the audio/video output.
 *
 * @param playbackSession    Handle to the media decode session to be blocked/
 *                           unblocked.
 * @param block              Boolean indicating whether to block (TRUE) or
 *                           unblock (FALSE).
 *
 * @return MPE_HN_ERR_NOERR            If successful.
 *         MPE_HN_ERR_INVALID_PARAM    If a parameter is invalid.
 *         MPE_HN_ERR_OS_FAILURE       OS-specific failures.
 **/
mpe_Error mpeos_hnPlayerPlaybackBlockPresentation(
        mpe_HnPlaybackSession playbackSession, mpe_Bool block);

/**
 * Pause the desired HN player playback session.  Pausing a playback session is
 * accomplished by stopping socket reads also known as connection stalling.
 * The playback halts but remains the session remains open.  The playback
 * remains in this state until it is resumed via mpeos_hnPlayerPlaybackResume()
 * or server side terminates connection due to inactivity.
 *
 * @param playbackSession    Handle to the media decode session to be paused
 *
 * @return MPE_HN_ERR_NOERR            If successful.
 *         MPE_HN_ERR_INVALID_PARAM    If a parameter is invalid.
 *         MPE_HN_ERR_OS_FAILURE       OS-specific failures.
 **/
mpe_Error mpeos_hnPlayerPlaybackPause(
        mpe_HnPlaybackSession playbackSession);

/**
 * Resume the desired HN player playback session.  Resuming a paused playback
 * session is accomplished by reactivating socket reads which were suspended
 * (referred to as connection stalling).  The playback will re-initiate presentation
 * of video and audio as content stream is read.
 *
 * @param playbackSession    Handle to the media decode session to be paused
 *
 * @return MPE_HN_ERR_NOERR            If successful.
 *         MPE_HN_ERR_INVALID_PARAM    If a parameter is invalid.
 *         MPE_HN_ERR_OS_FAILURE       OS-specific failures.
 **/
mpe_Error mpeos_hnPlayerPlaybackResume(
        mpe_HnPlaybackSession playbackSession);

/**
 * Set the current mute state. Audio must be muted if mute is TRUE regardless
 * of content format and the gain value must be unaffected. When FALSE, audio
 * must be restored and gain must be set to the pre-mute level.
 *
 * @param playbackSession    Handle of the playback to set the mute setting.
 * @param mute               Requested mute value.
 *
 * @return MPE_HN_ERR_NOERR            If successful.
 *         MPE_HN_ERR_INVALID_PARAM    If a parameter is invalid.
 *         MPE_HN_ERR_OS_FAILURE       OS-specific failures.
 **/
mpe_Error mpeos_hnPlayerPlaybackSetMute(mpe_HnPlaybackSession playbackSession,
        mpe_Bool mute);

/**
 * Set the current decibel gain for the supplied HN player playback session.
 * Positive values amplify the audio signal and negative values attenuate the
 * signal.
 *
 * If the platform does not support the setting of the gain level for the
 * presenting content format, actualGain should be returned as 0.0.
 *
 * @param playbackSession    Handle of the playback to set the gain on.
 * @param gain               Requested gain value, in decibels.
 * @param actualGain         Pointer to a float which will be assigned the new
 *                           gain setting.
 *
 * @return MPE_HN_ERR_NOERR            If successful.
 *         MPE_HN_ERR_INVALID_PARAM    If any of the parameters is invalid.
 *         MPE_HN_ERR_OS_FAILURE       OS-specific failures.
 **/
mpe_Error mpeos_hnPlayerPlaybackSetGain(mpe_HnPlaybackSession playbackSession,
        float gain, float * actualGain);

/**
 * Initialize the 3D config info.
 *
 * @return MPE_HN_ERR_NOERR         If successful.
 *         MPE_HN_ERR_OS_FAILURE    OS-specific failures.
 **/
mpe_Error mpeos_hnPlayerPlaybackInit3DConfig(void);

/**
 * Get the current input video scan mode.
 *
 * @param session is the active decode session to query for the scan mode
 * @param scanMode pointer to the field to be set with the current
 *        mpe_MediaScanMode
 *
 * @return MPE_EINVAL if session is invalid
 * @return MPE_SUCCESS if successful.
 */
mpe_Error mpeos_hnPlayerPlaybackGetVideoScanMode (mpe_HnPlaybackSession session, 
        mpe_MediaScanMode* scanMode);

/**
 * Get the 3DTV configuration for the HN player playback.
 *
 * @param playback           Active HN playback session to query for the 3D
 *                           configuration.
 * @param stereoscopicMode   Pointer to the field to be set with the current
 *                           mpe_Media3DFormatType.
 * @param payloadType        Pointer to the field to be set with the current
 *                           mpe_Media3DPayloadType.
 * @param payload            Pointer to the field to be set with the current
 *                           payload of the 3DTV information description
 *                           message.  The payload memory is allocated by the
 *                           caller and its size is passed in via payloadSz.
 *                           The MPEOS layer then copies the actual payload
 *                           size into payloadSz. If the payload mem block is
 *                           too small to contain the payload, MPE_ENOMEM is
 *                           returned and the necessary storage size is
 *                           returned via payloadSz.
 * @param payloadSz          As input, payloadSz is the size in bytes of the
 *                           memory allocated for the payload. As output,
 *                           payloadSz contains the size of the actual number
 *                           of bytes copied into the payload mem block. If the
 *                           payload mem block is too small to contain the
 *                           payload, MPE_ENOMEM is returned and the necessary
 *                           storage size is returned via payloadSz.
 *
 * @return MPE_HN_ERR_NOERR            If successful.
 *         MPE_HN_ERR_INVALID_PARAM    If any of the parameters is invalid.
 *         MPE_ENOMEM                  If payloadSz is too small to accommodate
 *                                     the 3DTV configuration.
 **/
mpe_Error mpeos_hnPlayerPlaybackGet3DConfig(mpe_HnPlaybackSession playback,
        mpe_DispStereoscopicMode* stereoscopicMode,
        mpe_Media3DPayloadType * payloadType,
        uint8_t * payload, uint32_t * payloadSz);

/**
 * Returns the number of DLNA profile IDs that the underlying HN player
 * implementation is able to support.
 *
 * @param profileIDCnt    Returns number/count of player-supported DLNA profile
 *                        IDs. The underlying HN player implementation should
 *                        never include "DTCP_"-prefixed profiles in this
 *                        enumeration.
 *
 * @return MPE_HN_ERR_NOERR            If successful.
 *         MPE_HN_ERR_INVALID_PARAM    If a parameter is invalid.
 **/
mpe_Error mpeos_hnPlayerGetDLNAProfileIDsCnt(uint32_t * profileIDCnt);

/**
 * Returns DLNA profile ID string at requested index from array of possible
 * DLNA profile IDs supported by the underlying HN player platform. This method
 * will return profileIDStr, assuming caller has allocated memory whose size is
 * MPE_HN_MAX_DLNA_PROFILE_ID_STR_SIZE.
 *
 * The index number also indicates the platform preferred DLNA profile ID. For
 * example, index 0 is the most preferred playback format, index 1 is the
 * second most preferred format, etc.
 *
 * @param idx             Retrieve this index in array of supported profile IDs
 *                        (indices start at 0, through count-1), based on count
 *                        returned via mpeos_hnPlayerGetDLNAProfileIDsCnt().
 * @param profileIDStr    Returns requested DLNA profile ID string at specified
 *                        index in caller allocated memory of
 *                        MPE_HN_MAX_DLNA_PROFILE_ID_STR_SIZE. The HN player
 *                        implementation should never include "DTCP_"-prefixed
 *                        profiles in this enumeration.
 *
 * @return MPE_HN_ERR_NOERR            If successful.
 *         MPE_HN_ERR_INVALID_PARAM    If one of the parameters is invalid.
 **/
mpe_Error mpeos_hnPlayerGetDLNAProfileIDStr(uint32_t idx,
        char profileIDStr[MPE_HN_MAX_DLNA_PROFILE_ID_STR_SIZE]);

/**
 * Retrieves number/count of HN player platform supported mime types for a
 * given DLNA profile ID. Some DLNA media profiles support multiple mime types;
 * for more information refer to DLNA Guidelines Volume 2: Media Format
 * Profiles.
 *
 * @param profileIdStr    Retrieve supported mime type count for this
 *                        particular profile ID. The stack can pass "DTCP_"-
 *                        prefixed profile ID to query the HN player platform
 *                        for a list of supported mime types that can be
 *                        received using with PCP header encapsulation applied
 *                        to the incoming content.
 * @param mimeTypeCnt     Returns number/count of supported mime types. The
 *                        underlying HN player implementation should never
 *                        include "application/x-dtcp1" mime type in this
 *                        enumeration.
 *
 * @return MPE_HN_ERR_NOERR            If successful.
 *         MPE_HN_ERR_INVALID_PARAM    If one of the parameters is invalid.
 **/
mpe_Error mpeos_hnPlayerGetMimeTypesCnt(char * profileIdStr,
        uint32_t * mimeTypeCnt);

/**
 * Returns supported mime type strings for a particular DLNA profile ID. This
 * method will return mime type string at particular index, written into caller
 * allocated memory of size MPE_HN_MAX_MIME_TYPE_STR_SIZE.
 *
 * The index number also indicates the platform preferred mime type for the
 * passed DLNA profile ID. For example, index 0 is the most preferred playback
 * format, index 1 is the second most preferred format, etc.
 *
 * @param profileIDStr    Retrieve supported mime type for this profile ID. The
 *                        stack can pass "DTCP_"-prefixed profile ID to query
 *                        the HN player platform for a list of supported mime
 *                        types that can be received with PCP header
 *                        encapsulation applied to the incoming content.
 * @param idx             With range as returned in mimeTypeCnt for
 *                        mpeos_hnPlayerGetMimeTypesCnt().
 * @param mimeTypeStr     Returns requested mime type string at specified index
 *                        in caller allocated memory of size
 *                        MPE_HN_MAX_DLNA_PROFILE_ID_STR_SIZE. The underlying
 *                        HN player implementation should never include
 *                        "application/x-dtcp1" mime type in this enumeration.
 *
 * @return MPE_HN_ERR_NOERR            If successful.
 *         MPE_HN_ERR_INVALID_PARAM    If one of the parameters is invalid.
 **/
mpe_Error mpeos_hnPlayerGetMimeTypeStr(char * profileIDStr, uint32_t idx,
        char mimeTypeStr[MPE_HN_MAX_MIME_TYPE_STR_SIZE]);

/**
 * Retrieves number/count of player platform supported playspeeds for the given
 * DLNA profile ID and mime type combination.
 *
 * @param profileIDStr    Retrieve supported playspeed count for the specified
 *                        DLNA media format. The stack can pass "DTCP_"-
 *                        prefixed profile ID to query the HN player platform
 *                        for a list of supported playspeeds that can be
 *                        received with PCP header encapsulation applied to the
 *                        incoming content.
 * @param mimeTypeStr     Retrieve supported playspeed count for the specified
 *                        mime type. The stack will never pass "application/x-
 *                        dtcp1" mime type here.
 * @param playspeedCnt    Returns number/count of supported playspeeds for the
 *                        supplied profileId/mime type combination.
 *
 * @return MPE_HN_ERR_NOERR            If successful.
 *         MPE_HN_ERR_INVALID_PARAM    If one of the parameters is invalid.
 **/
mpe_Error mpeos_hnPlayerGetPlayspeedsCnt(char * profileIDStr,
        char * mimeTypeStr, uint32_t * playspeedCnt);

/**
 * Returns playspeed strings such as "-2", "-1/2", "2", etc. which are
 * supported for the specified DLNA profile ID and mime type combination.
 *
 * This method will return playspeed string, assuming caller has allocated
 * memory whose size is MPE_HN_MAX_PLAYSPEED_STR_SIZE.
 *
 * @param profileIDStr    Retrieve supported playspeed for this DLNA media
 *                        profile. The stack can pass "DTCP_"-prefixed profile
 *                        ID to query the HN player platform for a particular
 *                        playspeed setting that can be received with PCP
 *                        header encapsulation applied to the incoming content.
 * @param mimeTypeStr     Retrieve supported playspeed for this mime type. The
 *                        stack will never pass "application/x-dtcp1" mime type
 *                        here.
 * @param idx             Retrieve this index in array of supported playspeeds
 *                        (indices start at 0, through count-1), based on count
 *                        returned via mpeos_hnPlayerGetPlayspeedsCnt().
 * @param playspeedStr    Returns playspeed string at specified index using
 *                        caller allocated memory of
 *                        MPE_HN_MAX_PLAYSPEED_STR_SIZE.
 *
 * @return MPE_HN_ERR_NOERR            If successful.
 *         MPE_HN_ERR_INVALID_PARAM    If one of the parameters is invalid.
 **/
mpe_Error mpeos_hnPlayerGetPlayspeedStr(char* profileIDStr, char* mimeTypeStr,
        uint32_t idx, char playspeedStr[MPE_HN_MAX_PLAYSPEED_STR_SIZE]);

///@}
#ifdef __cplusplus
}
#endif

#endif // _MPEOS_HN_H_
