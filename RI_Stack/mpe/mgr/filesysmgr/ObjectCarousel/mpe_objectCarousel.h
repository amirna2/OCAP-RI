// COPYRIGHT_BEGIN
//  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER
//  
//  Copyright (C) 2008-2013, Cable Television Laboratories, Inc. 
//  
//  This software is available under multiple licenses: 
//  
//  (1) BSD 2-clause 
//   Redistribution and use in source and binary forms, with or without modification, are
//   permitted provided that the following conditions are met:
//        ·Redistributions of source code must retain the above copyright notice, this list 
//             of conditions and the following disclaimer.
//        ·Redistributions in binary form must reproduce the above copyright notice, this list of conditions 
//             and the following disclaimer in the documentation and/or other materials provided with the 
//             distribution.
//   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
//   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED 
//   TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
//   PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
//   HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
//   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
//   LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, 
//   DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY 
//   THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
//   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF 
//   THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//  
//  (2) GPL Version 2
//   This program is free software; you can redistribute it and/or modify
//   it under the terms of the GNU General Public License as published by
//   the Free Software Foundation, version 2. This program is distributed
//   in the hope that it will be useful, but WITHOUT ANY WARRANTY; without
//   even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
//   PURPOSE. See the GNU General Public License for more details.
//  
//   You should have received a copy of the GNU General Public License along
//   with this program.If not, see<http:www.gnu.org/licenses/>.
//  
//  (3)CableLabs License
//   If you or the company you represent has a separate agreement with CableLabs
//   concerning the use of this code, your rights and obligations with respect
//   to this code shall be as set forth therein. No license is granted hereunder
//   for any other purpose.
//  
//   Please contact CableLabs if you need additional information or 
//   have any questions.
//  
//       CableLabs
//       858 Coal Creek Cir
//       Louisville, CO 80027-9750
//       303 661-9100
// COPYRIGHT_END

/* Generated by Together */

#ifndef MPE_OBJECTCAROUSEL_H
#define MPE_OBJECTCAROUSEL_H

#include "mpe_types.h"
#include "mpe_dataCarousel.h"
#include "mpe_objectCarouselBIOPParser.h"
#include "mpe_objectCarouselSectionParser.h"
#include "mpe_objectCarouselUtils.h"
#include "mpe_si.h"
#include "mpe_file.h"

#ifdef __cplusplus
"C"
{
#endif

#define MPE_OC_INVALID_VERSION      (0xffffffff)

    /*
     * Must implement the following interfaces:
     *   mpeos_fileInit         => implicit in mpe_ocMount
     *   mpeos_fileFileOpen     => mpe_ocOpenFile
     *   mpeos_fileFileClose    => mpe_ocCloseFile
     *   mpeos_fileFileRead     => mpe_ocReadFile
     *   mpeos_fileFileGetStat  => mpe_ocGetFileSize
     *   mpeos_fileFileGetFStat => mpe_ocGetFileSize
     *   mpeos_fileDirOpen      => mpe_ocOpenFile
     *   mpeos_fileDirRead      => mpe_ocListDirectory
     *   mpeos_fileDirClose     => mpe_ocCloseFile
     *   mpeos_fileDirMount     => mpe_ocMount
     *   mpeos_fileDirUnmount   => mpe_ocUnmount
     *   mpeos_fileDirGetUStat
     * The following are not implemented by the OC, but are handled above
     *   mpeos_fileFileSeek
     * The following are not implemented, due to the read-only nature of object
     * carousels, and are punted by the layer above.
     *   mpeos_fileFileWrite
     *   mpeos_fileFileSync
     *   mpeos_fileFileSetStat
     *   mpeos_fileFileSetFStat
     *   mpeos_fileFileDelete
     *   mpeos_fileFileRename
     *   mpeos_fileDirDelete
     *   mpeos_fileDirRename
     *   mpeos_fileDirCreate
     *   mpeos_fileDirSetUStat
     */

    typedef enum
    {
        Type_File,
        Type_Directory,
        Type_Stream,
        Type_StreamEvent,
    }mpe_OcFileType;

    typedef struct
    {
        ocpTAP tap;
        mpe_DataCarousel *dc;
    }mpe_ocComponentDC;

    typedef void (mpe_OcVersionCallbackFunc)(void *, uint32_t);

    typedef struct
    {
        ocpBIOPObjectLocation gatewayLoc; // Location of the gateway
        ocpTAP gatewayTAP;

        uint32_t carouselID; // The CarouselID in this carousel.

        // Cached values from above.
        mpe_DataCarousel *gatewayDC; // Gateway data carousel
        uint32_t gatewayTimeout; // Timeout, in milliseconds, to wait for the

        mpe_SiServiceHandle siHandle; // Service Handle to get SI Data
        mpe_FilterSource rootTS; // Transport stream/PID containing the root DSI.
        mpe_OcTuningParams rootParams;
        uint8_t nsapAddress[OCP_DSI_SERVERID_LENGTH];

        mpe_Bool iso88591; // Is this encoded in ISO 8859-1, or UTF-8

        // Component data carousels which make up this carousel
        // Can't mount more than DC_MAX_DATA_CAROUSELS total, so that's our max here
        mpe_ocComponentDC dataCarousels[DC_MAX_DATACAROUSELS];
        uint32_t referenceCount;
        mpe_Bool mounted;
        mpe_EventQueue updateQueue;
        mpe_Bool updateQueueRegistered;
        void *updateData;
        void *userData;
    }mpe_ObjectCarousel;

    typedef struct
    {
        mpe_ObjectCarousel *oc; // The OC this file lives in
        mpe_DcModule *module; // The module that contains this file
        uint32_t dataOffset; // Offset to the first byte in the file proper.
        uint32_t length; // Length of the file (not including the BIOP::File message header)
        int fileType; // File type of this file (file, dir, stream)
        ocpBIOPObject *biopObject; // The BIOP Object record pointing to this file.
        uint32_t timeout; // Timeout for DDB's, in milliseconds
    }mpe_OcFile;

    typedef struct
    {
        uint32_t size;
        uint32_t version;
        mpe_OcFileType fileType;
        char *mimeType;
        char name[1];
    }mpe_OcDirEntry;

    typedef struct
    {
        uint32_t eventID;
        char name[1];
    }mpe_OcStreamEventEntry;

    // Types of streams that a stream object can specify.
    typedef enum
    {
        StreamType_Audio,
        StreamType_Video,
        StreamType_Data,
    }mpe_OcStreamType;

    /**
     * Initialize the object carousel system.
     */
    mpe_Error mpe_ocInit(void);

    /**
     * This function mounts an object carousel, loads the service gateway, and prepares the
     * carousel to have file opened.
     *
     * @param siHandle   A Handle to the SI DB to fetch the carousel ID containing the DSI
     * @param carouselID The carousel ID of the carousel to mount.
     * @param oc         Return pointer to fill in with the object carousel object after it has been mounted.
     *
     * @returns MPE_SUCCESS if the carousel is mounted correctly, error codes otherwise.
     */
    mpe_Error mpe_ocMount(mpe_SiServiceHandle siHandle, uint32_t carouselID, mpe_ObjectCarousel * * oc);

    /**
     * This function unmounts an object carousel, and releases all it's memory.  It does no error checking to
     * determine if any files are open in the object carousel, so the caller must make sure that the carousel
     * is ready to be unmounted.  Further attempts to access the carousel can result in random memory accesses.
     * Unmounts the underyling data carousel as well.
     *
     * @param oc The object carousel to unmount.
     *
     * @returns MPE_SUCCESS if the object carousel is unmounted correctly.
     */
    mpe_Error mpe_ocUnmount(mpe_ObjectCarousel *oc);

    /**
     * Open a file for reading.
     *
     * @param oc The object carousel the file exists within.
     * @param filename The full pathname of the file to open, relative to the object carousel root.
     * @param file Output pointer to fill in with the filename.
     *
     * @returns MPE_SUCCESS if the file is opened, error codes otherwise.
     */
    mpe_Error mpe_ocOpenFile(mpe_ObjectCarousel * oc, char * filename, mpe_Bool followLinks, mpe_DcCacheMode cacheMode, mpe_OcFile **file);

    /**
     * Close a file and delete all the data structures corresponding to it.
     *
     * @param file The file pointer to close.
     *
     * @returns MPE_SUCCESS.
     */
    mpe_Error mpe_ocCloseFile(mpe_OcFile *file);

    /**
     * Read data from an object carousel file.  This will only work if the file type
     * is a file.  It will not work if the file is a directory or a stream.  Directories
     * should be read via the mpe_ocListDirectory() function.
     *
     * @param file The file to read the data from.
     * @param start The location at which to start reading.
     * @param length The number of bytes to read.
     * @param output An array with which to fill with data. [output]
     * @param bytesRead Output parameter to fill with number of bytes read.
     *
     * @returns MPE_SUCCESS if the read completes, error codes otherwise.
     */
    mpe_Error mpe_ocReadFile(mpe_OcFile *file, uint32_t start, uint32_t length, uint8_t *output, uint32_t *bytesRead);

    /**
     * Get the file type of a file.
     *
     * @param oc The object carousel to look in.
     * @param file The file to get the path of.
     * @param fileType Output parameter of the file to be typed.  Return value is invalid if
     *                 not successful.
     *
     * @returns MPE_SUCCESS if the file exists and can be typed, error codes otherwise.
     */
    mpe_Error mpe_ocGetFileType(mpe_OcFile *file, mpe_OcFileType *fileType);

    /**
     * This function one of the entries in a directory.
     *
     * @param dir       The directory to read the directory out of.
     * @param entry     The entry to read.
     * @param retEntry  [out] Pointer to where to put a pointer to the read directory entry.
     *
     * @returns MPE_SUCCESS if successful, MPE_EINVAL if the file is not a directory,
     *          error codes otherwise.
     */
    mpe_Error mpe_ocReadDirectoryEntry(mpe_OcFile *dir, uint32_t entry, mpe_OcDirEntry **retEntry);

    /**
     * This function returns the directory entry for a given filename.  Will walk LiteOptionsProfileBody's
     * to other object carousels.
     *
     * @param oc        The object carousel containing the file.
     * @param filename  The name of the file to search for.
     * @param retEntry  [out] Pointer to where to put a pointer to the read directory entry.
     */
    mpe_Error mpe_ocGetDirectoryEntry(mpe_ObjectCarousel * oc, char *filename, mpe_OcDirEntry **retEntry);

    /**
     * This function frees a directory entry.  Callers should use this instead of freeing it themselves.
     *
     * @param dirEntry  The directory entry to free.
     */
    void mpe_ocFreeDirectoryEntry(mpe_OcDirEntry *dirEntry);

    /**
     * This functions returns an event from the StreamEvent.
     *
     * @param stream The StreamEvent to read the entry out of.
     * @param entry  The entry to read.
     * @param retEntry  [out] Pointer to where to put a pointer to the returned StreamEvent entry.
     *                  Caller is responsible for freeing this structure.
     *
     * @returns MPE_SUCCESS if successful, MPE_EINVAL if the file is not a directory,
     *          error codes otherwise.
     */
    mpe_Error mpe_ocReadStreamEventEntry(mpe_OcFile *stream, uint32_t entry, mpe_OcStreamEventEntry **retEntry);

    /**
     * This function causes a file to be unloaded, it's memory marked as eligible
     * for reallocation.  Can be applied to any file or directory, even if it wasn't
     * previously loaded.
     *
     * @param file The file to unload.
     *
     * @returns MPE_SUCCESS
     */
    mpe_Error mpe_ocUnloadFile(mpe_OcFile *file);

    /**
     * Return the size of a file.  Only works with file objects.
     *
     * @param file The file to get the size of.
     * @param size [out] Pointer to a variable to return the size in.
     *
     * @returns MPE_SUCCESS if successful, error codes otherwise.
     */
    mpe_Error mpe_ocGetFileSize(mpe_OcFile *file, uint32_t *size);

    /**
     * Get the version of a file in the object carousel.  Returns the version
     * number of the module containing file object.
     *
     * @param file      The file to get the version of.
     * @param version   [out] Pointer to where to indicate the version number.
     *
     * @returns MPE_SUCCESS if the version is found, error codes otherwise.
     */
    mpe_Error mpe_ocGetVersion(mpe_OcFile *file, uint32_t *version);

    /**
     * Is the file current (ie, up-to-date).
     *
     * @param file      The file to check.
     * @param isCurrent [out] Output parameter, where to put the result.
     *
     * @Returns MPE_SUCCESS if the check could be made.  Errors otherwise.
     */
    mpe_Error mpe_ocIsCurrent(mpe_OcFile *, mpe_Bool *);

    /**
     * Is the carousel connected?
     *
     * @param oc            The object carousel to query on.
     * @param connected     [out] Pointer to where to make the connection.
     *
     * @returns MPE_SUCCESS
     */
    mpe_Error mpe_ocIsConnected(mpe_ObjectCarousel *oc, mpe_Bool *connected);

    /**
     * Return whether a file is in a loaded module.
     *
     * @param file          The file to get the status of.
     * @param isLoaded      [out] Pointer to where to put the status.
     */
    mpe_Error mpe_ocGetFileLoadedStatus(mpe_OcFile *file, mpe_Bool *isLoaded);

    /**
     * Return whether this stream has a certain type of stream.  Audio, Video, or MPEG Program.
     *
     * @param file          The Stream "file" to check for this type.
     * @param isType        The type to determine if this stream is
     * @param result        [out] Boolean, does this stream have the right type
     *
     * @returns MPE_SUCCESS if it could be determined if this type is there.
     */
    mpe_Error mpe_ocIsStreamType(mpe_OcFile *file, mpe_OcStreamType isType, mpe_Bool *result);

    /**
     * Return info about where to find the carousel.
     *
     * @param file          The stream we're working with.
     * @param freq          [out] Pointer to where to fill in frequency from the TAP.
     * @param prog          [out] Pointer to where to fill in program from the TAP.
     * @param qam           [out] Pointer to where to fill in QAM mode from the TAP.
     * @param sourceID      [out] Pointer to where to fill in the sourceID, if it exists.  -1 if not.
     *
     * @returns MPE_SUCCESS
     */
    mpe_Error mpe_ocGetTuningInfo(mpe_OcFile *file, uint32_t *freq, uint32_t *prog, mpe_SiModulationMode *qam, uint32_t *sourceId);

    /**
     * Return the number of taps of a given type.
     *
     * @param file          The stream we're working with.
     * @param tapType       The tap type to look for.  MPE_OC_ALL_TAPS to get all the taps.
     * @param numTaps       [out] Pointer to where to put the
     *
     * @returns MPE_SUCCESS if returning a valid number, error codes otherwise.
     */
    mpe_Error mpe_ocGetNumTaps(mpe_OcFile *file, uint16_t tapType, uint32_t *numTaps);

    /**
     * Return the tag value of a tap of a given type.
     * @param file          The stream we're working with.
     * @param tapType       Type of the TAP we're looking for.  Only finds the first TAP for any type.
     * @param tapInstance   Occurrance of the TAP we're looking for.
     * @param tapTag        [out] Pointer to where to fill in the tag from the TAP.
     * @param tapId         [out] Pointer to where to fill in the ID from the TAP.
     *
     * @returns MPE_SUCCESS if found, MPE_NODATA if not, other error codes as appropriate.
     */
    mpe_Error mpe_ocGetTap(mpe_OcFile *file, uint16_t tapType, uint32_t tapInstance, uint16_t *tapTag, uint16_t *tapId);

    /**
     * Get the duration of the stream in milliseconds.  Converts it from the seconds + microSeconds
     * that the stream uses internally.
     *
     * @param file      The stream to use.
     * @param duration  [out] Where to put the duration.
     *
     * @returns MPE_SUCCESS if it successfully calculated the duration, MPE_EINVAL if the arguments are wrong.
     */
    mpe_Error mpe_ocGetStreamDuration(mpe_OcFile *file, uint64_t *duration);

    /**
     * Retrieve the content type field from within an object.
     * This gets the version of it that's in a file.  It can also be in stored in the directory entry,
     * and this will not get that version.
     */
    mpe_Error mpe_ocGetContentType(mpe_OcFile *file, uint32_t size, char *buffer);

    /**
     * Find an object carousel by the NSAP address.
     *
     * @param NSAP The address to search for.
     * @param retOc [out] Pointer to where to return the object carousel, if found.
     *
     * @returns MPE_SUCCESS if found, MPE_EINVAL if not.
     */
    mpe_Error mpe_ocFindCarouselByNSAPAddress(uint8_t *nsap, mpe_ObjectCarousel **retOC);

    /**
     * Set an event queue to respond to when anything in the object carousel changes.
     *
     * @param oc        The object carousel to set the change on.
     * @param queue     The queue to assign.
     * @param data      The data to send back with the version updated event.
     *
     * @returns MPE_SUCCESS if the version change is set correctly.
     */
    mpe_Error mpe_ocSetChangeNotification(mpe_ObjectCarousel *oc, mpe_EventQueue queueId, void *data);

    /**
     * Unregister any event queue currently registered with this obejct carousel
     *
     * @param oc        The object carousel to set the change on.
     *
     * @returns MPE_SUCCESS if the registered event queue is unregistered
     */
    mpe_Error mpe_ocUnsetChangeNotification(mpe_ObjectCarousel *oc);

    /**
     * Add a DII (data carousel), as specified by the TAP, into the object carousel.
     *
     * @param oc        The object carousel to add the tap to.
     *
     * @returns MPE_SUCCESS if the tap can be added, or is already there.  Error codes if it can't be added.
     */
    mpe_Error mpe_ocAddDII(mpe_ObjectCarousel *oc, uint16_t diiIdentification, uint16_t assocTag);

    /**
     * Prefetch a module (or modules) based on the name.
     *
     * @param oc            The object carousel to add the tap to.
     * @param moduleName    The module name to prefetch.
     *
     * @returns MPE_SUCCESS if the tap can be added, or is already there.  Error codes if it can't be added.
     */
    mpe_Error mpe_ocPrefetchModule(mpe_ObjectCarousel *oc, const char *moduleName);

    /**
     * Prefetch a file based on the name.  Grads the entire module containing the file.
     *
     * @param oc            The object carousel to add the tap to.
     * @param fileName      The file name to prefetch.
     *
     * @returns MPE_SUCCESS if the tap can be added, or is already there.  Error codes if it can't be added.
     */
    mpe_Error mpe_ocPrefetchFile(mpe_ObjectCarousel *oc, char *fileName);

    /**
     * Resolve a pathname that contains a LiteOptionsProfileBody object.
     *
     * @param oc            The object carousel to start in.
     * @param fileName      The pathname to resolve.
     * @param maxLength     Number of bytes in the target name buffer.
     * @param targetName    [out] Buffer to be filled with the name.  At least maxLength bytes long.
     * @param nsap          [out] Buffer to fill with the NSAP address.  Must be 20 bytes long.
     */
    mpe_Error mpe_ocResolveFilename(mpe_ObjectCarousel *oc, char *fileName, uint32_t maxLength, char *targetName, uint8_t *nsap);

    /**
     * Increment the reference count on a carousel.
     * Will prevent it from being unmounted completely until it goes to 0.
     * Can only increment the count on mounted carousels.
     *
     * @param The carousel to increment the ref count on.
     *
     * @returns True if the carousel was mounted.  False if it wasn't.
     */
    mpe_Bool mpe_ocReferenceOC(mpe_ObjectCarousel *);

    /**
     * Decrement the reference count on a carousel.  If the carousel is unmounted, and the ref count
     * goes to 0, the carousel will be freed.
     *
     * @param The carousel to decrement the ref count on.
     *
     * @returns True if the carousel was freed as part of this call.  False if it wasn't.
     */
    mpe_Bool mpe_ocDereferenceOC(mpe_ObjectCarousel *);

    /**
     * Add user data to a carousel.  Overwrites whatever was there before.  Use with caution.
     * Note: The user is responsible for deallocating any data in this structure when
     * getting rid of the carousel.
     *
     * @param oc  The carousel to add data to.
     * @param data The data to add.
     */
    void mpe_ocSetUserData(mpe_ObjectCarousel *, void *);

    /**
     * Return the data registered with mpe_ocSetUserData().
     *
     * @param oc    The carousel to retrieve data from.
     *
     * @returns     The data.
     */
    void * mpe_ocGetUserData(mpe_ObjectCarousel *);

    /**
     * Set a new service handle into the carousel.
     *
     * @param   oc      The carousel to set the handle in.
     * @param   handle  The new handle.
     *
     * @returns MPE_SUCCESS if the SI handle is set.  Errors otherwise.
     */
    mpe_Error mpe_ocSetSIHandle(mpe_ObjectCarousel *, mpe_SiServiceHandle);

    /**
     * Get the SI Handle from a file.
     *
     * @param   file    The file to get the SI Handle from.
     * @param   handle  Pointer to a location to put the SI Handle in.
     *
     * @returns MPE_SUCCESS if the SI handle is retrieved.  Errors otherwise.
     */
    mpe_Error mpe_ocGetSIHandle(mpe_OcFile *, mpe_SiServiceHandle *);

#ifdef __cplusplus
}
#endif

#endif /* MPE_OBJECTCAROUSEL_H */
