--- ocHnNetConfig.c	2013-04-29 18:02:07.649676821 -0600
+++ orig/ocHnNetConfig.c	2013-04-29 18:02:52.855679563 -0600
@@ -1,6 +1,6 @@
 /*
  * Note: this file originally auto-generated by mib2c using
- *        : mib2c.scalar.conf 11805 2005-01-07 09:37:18Z dts12 $
+ *        $
  */
 
 #include <net-snmp/net-snmp-config.h>
@@ -8,11 +8,17 @@
 #include <net-snmp/agent/net-snmp-agent-includes.h>
 #include "ocHnNetConfig.h"
 
+int ocHnNetConfigViewPrimaryOutputPort = 2;     // default to SNMP false(2)
+long ocHnNetConfigViewPrimaryOutputPortOrgID = 0;     // default to 0 (No write access by Org)
+int ocHnNetConfigPersistentLinkLocalAddress = 2;     // default to SNMP false(2)
+
 /** Initializes the ocHnNetConfig module */
 void
 init_ocHnNetConfig(void)
 {
-    static oid ocHnNetConfigViewPrimaryOutputPort_oid[] = { 1,3,6,1,4,1,4491,2,3,2,2,5,1 };
+    const oid ocHnNetConfigViewPrimaryOutputPort_oid[] = { 1,3,6,1,4,1,4491,2,3,2,2,5,1 };
+    const oid ocHnNetConfigViewPrimaryOutputPortOrgID_oid[] = { 1,3,6,1,4,1,4491,2,3,2,2,5,2 };
+    const oid ocHnNetConfigPersistentLinkLocalAddress_oid[] = { 1,3,6,1,4,1,4491,2,3,2,2,5,3 };
 
   DEBUGMSGTL(("ocHnNetConfig", "Initializing\n"));
 
@@ -21,6 +27,16 @@
                                ocHnNetConfigViewPrimaryOutputPort_oid, OID_LENGTH(ocHnNetConfigViewPrimaryOutputPort_oid),
                                HANDLER_CAN_RWRITE
         ));
+    netsnmp_register_scalar(
+        netsnmp_create_handler_registration("ocHnNetConfigViewPrimaryOutputPortOrgID", handle_ocHnNetConfigViewPrimaryOutputPortOrgID,
+                               ocHnNetConfigViewPrimaryOutputPortOrgID_oid, OID_LENGTH(ocHnNetConfigViewPrimaryOutputPortOrgID_oid),
+                               HANDLER_CAN_RWRITE
+        ));
+    netsnmp_register_scalar(
+        netsnmp_create_handler_registration("ocHnNetConfigPersistentLinkLocalAddress", handle_ocHnNetConfigPersistentLinkLocalAddress,
+                               ocHnNetConfigPersistentLinkLocalAddress_oid, OID_LENGTH(ocHnNetConfigPersistentLinkLocalAddress_oid),
+                               HANDLER_CAN_RWRITE
+        ));
 }
 
 int
@@ -30,6 +46,7 @@
                           netsnmp_request_info         *requests)
 {
     int ret;
+    static int undoVal = 0;
     /* We are never called for a GETNEXT if it's registered as a
        "instance", as it's "magically" handled for us.  */
 
@@ -40,8 +57,10 @@
 
         case MODE_GET:
             snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
-                                     (u_char *) /* XXX: a pointer to the scalar's data */,
-                                     /* XXX: the length of the data in bytes */);
+                                 (u_char *)&ocHnNetConfigViewPrimaryOutputPort,
+                                 sizeof(ocHnNetConfigViewPrimaryOutputPort));
+            snmp_log(LOG_INFO, "%s MODE_GET called (returning %d)\n",
+                     __func__, ocHnNetConfigViewPrimaryOutputPort);
             break;
 
         /*
@@ -59,44 +78,181 @@
             break;
 
         case MODE_SET_RESERVE2:
-            /* XXX malloc "undo" storage buffer */
-            if (/* XXX if malloc, or whatever, failed: */) {
-                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_RESOURCEUNAVAILABLE);
-            }
+            undoVal = ocHnNetConfigViewPrimaryOutputPort;
+            snmp_log(LOG_INFO, "%s MODE_SET_RESERVE2 called.\n", __func__);
             break;
 
         case MODE_SET_FREE:
-            /* XXX: free resources allocated in RESERVE1 and/or
-               RESERVE2.  Something failed somewhere, and the states
-               below won't be called. */
+            snmp_log(LOG_INFO, "%s MODE_SET_FREE called.\n", __func__);
             break;
 
         case MODE_SET_ACTION:
-            /* XXX: perform the value change here */
-            if (/* XXX: error? */) {
-                netsnmp_set_request_error(reqinfo, requests, /* some error */);
-            }
+            snmp_log(LOG_INFO, "%s MODE_SET_ACTION called (%d <- %ld)\n",
+                     __func__, ocHnNetConfigViewPrimaryOutputPort,
+                     *requests->requestvb->val.integer);
             break;
 
         case MODE_SET_COMMIT:
-            /* XXX: delete temporary storage */
-            if (/* XXX: error? */) {
-                /* try _really_really_ hard to never get to this point */
-                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_COMMITFAILED);
+            snmp_log(LOG_INFO, "%s MODE_SET_COMMIT called.\n", __func__);
+            ocHnNetConfigViewPrimaryOutputPort =
+                     *requests->requestvb->val.integer;
+            break;
+
+        case MODE_SET_UNDO:
+            snmp_log(LOG_INFO, "%s MODE_SET_UNDO called.\n", __func__);
+            ocHnNetConfigViewPrimaryOutputPort = undoVal;
+            break;
+
+        default:
+            /* we should never get here, so this is a really bad error */
+            snmp_log(LOG_ERR, "unknown mode (%d) in handle_ocHnNetConfigViewPrimaryOutputPort\n", reqinfo->mode );
+            return SNMP_ERR_GENERR;
+    }
+
+    return SNMP_ERR_NOERROR;
+}
+int
+handle_ocHnNetConfigViewPrimaryOutputPortOrgID(netsnmp_mib_handler *handler,
+                          netsnmp_handler_registration *reginfo,
+                          netsnmp_agent_request_info   *reqinfo,
+                          netsnmp_request_info         *requests)
+{
+    int ret;
+    static unsigned long undoVal = 0;
+    /* We are never called for a GETNEXT if it's registered as a
+       "instance", as it's "magically" handled for us.  */
+
+    /* a instance handler also only hands us one request at a time, so
+       we don't need to loop over a list of requests; we'll only get one. */
+    
+    switch(reqinfo->mode) {
+
+        case MODE_GET:
+            snmp_set_var_typed_value(requests->requestvb, ASN_UNSIGNED,
+                                 (u_char *)&ocHnNetConfigViewPrimaryOutputPortOrgID,
+                                 sizeof(ocHnNetConfigViewPrimaryOutputPortOrgID));
+            snmp_log(LOG_INFO, "%s MODE_GET called (returning %ld)\n",
+                     __func__, ocHnNetConfigViewPrimaryOutputPortOrgID);
+            break;
+
+        /*
+         * SET REQUEST
+         *
+         * multiple states in the transaction.  See:
+         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
+         */
+        case MODE_SET_RESERVE1:
+                /* or you could use netsnmp_check_vb_type_and_size instead */
+            ret = netsnmp_check_vb_type(requests->requestvb, ASN_UNSIGNED);
+            if ( ret != SNMP_ERR_NOERROR ) {
+                netsnmp_set_request_error(reqinfo, requests, ret );
             }
             break;
 
+        case MODE_SET_RESERVE2:
+            undoVal = ocHnNetConfigViewPrimaryOutputPortOrgID;
+            snmp_log(LOG_INFO, "%s MODE_SET_RESERVE2 called.\n", __func__);
+            break;
+
+        case MODE_SET_FREE:
+            snmp_log(LOG_INFO, "%s MODE_SET_FREE called.\n", __func__);
+            break;
+
+        case MODE_SET_ACTION:
+            snmp_log(LOG_INFO, "%s MODE_SET_ACTION called (%ld <- %ld)\n",
+                     __func__, ocHnNetConfigViewPrimaryOutputPortOrgID,
+                     *requests->requestvb->val.integer);
+            break;
+
+        case MODE_SET_COMMIT:
+            //*requests->requestvb->val.integer is a pointer to a "long" 
+            snmp_log(LOG_INFO, "%s MODE_SET_COMMIT called.\n", __func__);
+            ocHnNetConfigViewPrimaryOutputPortOrgID =
+                     *requests->requestvb->val.integer;
+            break;
+
         case MODE_SET_UNDO:
-            /* XXX: UNDO and return to previous value for the object */
-            if (/* XXX: error? */) {
-                /* try _really_really_ hard to never get to this point */
-                netsnmp_set_request_error(reqinfo, requests, SNMP_ERR_UNDOFAILED);
+            snmp_log(LOG_INFO, "%s MODE_SET_UNDO called.\n", __func__);
+            ocHnNetConfigViewPrimaryOutputPortOrgID = undoVal;
+            break;
+
+        default:
+            /* we should never get here, so this is a really bad error */
+            snmp_log(LOG_ERR, "unknown mode (%d) in handle_ocHnNetConfigViewPrimaryOutputPortOrgID\n", reqinfo->mode );
+            return SNMP_ERR_GENERR;
+    }
+
+    return SNMP_ERR_NOERROR;
+}
+
+int
+handle_ocHnNetConfigPersistentLinkLocalAddress(netsnmp_mib_handler *handler,
+                          netsnmp_handler_registration *reginfo,
+                          netsnmp_agent_request_info   *reqinfo,
+                          netsnmp_request_info         *requests)
+{
+    int ret;
+    static int undoVal = 0;
+    /* We are never called for a GETNEXT if it's registered as a
+       "instance", as it's "magically" handled for us.  */
+
+    /* a instance handler also only hands us one request at a time, so
+       we don't need to loop over a list of requests; we'll only get one. */
+    
+    switch(reqinfo->mode) {
+
+        case MODE_GET:
+            snmp_set_var_typed_value(requests->requestvb, ASN_INTEGER,
+                          (u_char *)&ocHnNetConfigPersistentLinkLocalAddress,
+                          sizeof(ocHnNetConfigPersistentLinkLocalAddress));
+            snmp_log(LOG_INFO, "%s MODE_GET called (returning %d)\n",
+                     __func__, ocHnNetConfigPersistentLinkLocalAddress);
+            break;
+
+        /*
+         * SET REQUEST
+         *
+         * multiple states in the transaction.  See:
+         * http://www.net-snmp.org/tutorial-5/toolkit/mib_module/set-actions.jpg
+         */
+        case MODE_SET_RESERVE1:
+                /* or you could use netsnmp_check_vb_type_and_size instead */
+            ret = netsnmp_check_vb_type(requests->requestvb, ASN_INTEGER);
+            if ( ret != SNMP_ERR_NOERROR ) {
+                netsnmp_set_request_error(reqinfo, requests, ret );
             }
             break;
 
+        case MODE_SET_RESERVE2:
+            undoVal = ocHnNetConfigPersistentLinkLocalAddress;
+            snmp_log(LOG_INFO, "%s MODE_SET_RESERVE2 called.\n", __func__);
+            break;
+
+        case MODE_SET_FREE:
+            snmp_log(LOG_INFO, "%s MODE_SET_FREE called.\n", __func__);
+            break;
+
+        case MODE_SET_ACTION:
+            snmp_log(LOG_INFO, "%s MODE_SET_ACTION called (%d <- %ld)\n",
+                     __func__, ocHnNetConfigPersistentLinkLocalAddress,
+                     *requests->requestvb->val.integer);
+            break;
+
+        case MODE_SET_COMMIT:
+            //*requests->requestvb->val.integer is a pointer to a "long" 
+            snmp_log(LOG_INFO, "%s MODE_SET_COMMIT called.\n", __func__);
+            ocHnNetConfigPersistentLinkLocalAddress =
+                     *requests->requestvb->val.integer;
+            break;
+
+        case MODE_SET_UNDO:
+            snmp_log(LOG_INFO, "%s MODE_SET_UNDO called.\n", __func__);
+            ocHnNetConfigPersistentLinkLocalAddress = undoVal;
+            break;
+
         default:
             /* we should never get here, so this is a really bad error */
-            snmp_log(LOG_ERR, "unknown mode (%d) in handle_ocHnNetConfigViewPrimaryOutputPort\n", reqinfo->mode );
+            snmp_log(LOG_ERR, "unknown mode (%d) in handle_ocHnNetConfigPersistentLinkLocalAddress\n", reqinfo->mode );
             return SNMP_ERR_GENERR;
     }
 
